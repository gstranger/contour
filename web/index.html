<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>contour demo</title>
    <style>
      html, body { height: 100%; margin: 0; }
      body { font-family: system-ui, sans-serif; display: flex; flex-direction: column; }
      header { padding: 12px 16px; border-bottom: 1px solid #ddd; }
      #stage { flex: 1; position: relative; background: #fff; }
      canvas { width: 100%; height: 100%; display: block; background: #fafafa; }
      .hint { color: #666; font-size: 12px; }
    </style>
  </head>
  <body>
    <header>
      <div><strong>contour</strong> — (fills + paint bucket)</div>
      <div class="hint">
        Build with <code>wasm-pack build --target web</code>.
        Drag nodes. Connect: Alt+drag from node to node.
        Snap: <code>S</code>. Fill: <code>F</code>. Pen: <code>P</code>. Bend: <code>B</code>. Text: <code>T</code>. Rect: <code>U</code>. Ellipse: <code>O</code>.
        Undo: Ctrl/Cmd+Z. Redo: Shift+Ctrl/Cmd+Z.
      </div>
      <div style="margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <div id="toolbar" style="display:flex; gap:6px; align-items:center; border:1px solid #e2e2e2; border-radius:8px; padding:6px; background:#fff;">
          <button id="penBtn" title="Pen tool (P)">Pen</button>
          <select id="penMode" title="Pen mode" style="font-size:12px; padding:4px 6px; border:1px solid #e2e2e2; border-radius:6px; background:#fff;">
            <option value="points">Points</option>
            <option value="free">Free Draw</option>
          </select>
          <button id="bendBtn" title="Toggle bend tool (B)">Bend</button>
          <button id="bucketBtn" title="Toggle paint bucket (F)">Bucket</button>
          <button id="textBtn" title="Text tool (T)">Text</button>
          <button id="rectBtn" title="Rectangle tool (U)">Rect</button>
          <button id="ellipseBtn" title="Ellipse tool (O)">Ellipse</button>
          <button id="polygonBtn" title="Polygon tool (G)">Polygon</button>
          <button id="starBtn" title="Star tool (*)">Star</button>
          <button id="refBtn" title="Toggle reference SVG overlay (R)">Ref</button>
        </div>
        <div id="boolToolbar" style="display:flex; gap:6px; align-items:center; border:1px solid #e2e2e2; border-radius:8px; padding:6px; background:#fff;">
          <button id="inferShapesBtn" title="Detect closed shapes">Shapes</button>
          <button id="unionBtn" title="Union (combine shapes)" disabled>Union</button>
          <button id="intersectBtn" title="Intersect (overlap)" disabled>Intersect</button>
          <button id="diffBtn" title="Difference (subtract)" disabled>Diff</button>
          <button id="xorBtn" title="XOR (exclusive)" disabled>XOR</button>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="saveBtn">Save</button>
          <button id="loadBtn">Load</button>
          <button id="clearBtn">Clear</button>
          <button id="importBtn" title="Import an SVG file">Import SVG</button>
          <input id="importSvgInput" type="file" accept=".svg,image/svg+xml" style="display:none" />
        </div>
        <span class="hint" id="snapLabel"></span>
        <span class="hint" id="modeLabel"></span>
      </div>
    </header>
    <div id="main" style="flex:1; display:flex; min-height:0;">
      <div id="stage" style="flex:1; position:relative; background:#fff; min-width:0;">
        <canvas id="canvas"></canvas>
        <div id="hud" style="position:absolute; top:6px; left:8px; font:12px/1.4 system-ui, sans-serif; background:rgba(255,255,255,0.8); border:1px solid #e2e2e2; border-radius:6px; padding:4px 8px; color:#333; pointer-events:none;">
          loading…
        </div>
      </div>
      <aside id="sidebar" style="width:280px; border-left:1px solid #ddd; background:#fafbfc; display:flex; flex-direction:column; overflow:hidden;">
        <div style="padding:8px 10px; border-bottom:1px solid #eee; font-weight:600; flex:0 0 auto;">Objects</div>
        <div id="objList" style="padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto; flex:1 1 auto; min-height:120px;"></div>
        <div style="padding:8px 10px; border-top:1px solid #eee; font-weight:600; flex:0 0 auto;">Properties</div>
        <div id="props" style="padding:10px; display:flex; flex-direction:column; gap:10px; background:#fff; border-top:1px solid #eee; box-shadow:0 -4px 10px rgba(0,0,0,0.04); position:sticky; bottom:0; flex:0 0 auto;">
          <div class="hint">Select a path to edit style.</div>
        </div>
        <div id="textProps" style="padding:10px; display:none; flex-direction:column; gap:10px; background:#fff; border-top:1px solid #eee;">
          <div style="font-size:12px; color:#555;">Text Properties</div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label style="width:56px; font-size:12px;">Content</label>
            <input type="text" id="textContent" placeholder="Enter text..." style="flex:1; padding:4px 6px; border:1px solid #ddd; border-radius:4px;">
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label style="width:56px; font-size:12px;">Size</label>
            <input type="range" id="textSize" min="8" max="72" value="16" style="flex:1;">
            <span id="textSizeVal" style="width:36px; font-size:12px; text-align:right;">16px</span>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label style="width:56px; font-size:12px;">Align</label>
            <select id="textAlign" style="flex:1; padding:4px;">
              <option value="0">Left</option>
              <option value="1">Center</option>
              <option value="2">Right</option>
            </select>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label style="width:56px; font-size:12px;">Color</label>
            <input type="color" id="textColor" value="#000000" style="width:36px; height:24px; border:none;">
          </div>
          <div style="display:flex; gap:6px; margin-top:4px;">
            <button id="textToOutlinesBtn" style="flex:1; font-size:11px;">To Outlines</button>
            <button id="deleteTextBtn" style="flex:1; font-size:11px; color:#c00;">Delete</button>
          </div>
        </div>
        <div id="shapeProps" style="padding:10px; display:none; flex-direction:column; gap:10px; background:#fff; border-top:1px solid #eee;">
          <div style="font-size:12px; color:#555;">Shape Selection</div>
          <div id="shapeList" style="font-size:11px; color:#333;"></div>
          <div class="hint">Click shapes to select (up to 2 for boolean ops)</div>
        </div>
        <div id="primitiveSettings" style="padding:10px; display:none; flex-direction:column; gap:10px; background:#fff; border-top:1px solid #eee;">
          <div style="font-size:12px; color:#555;">Shape Settings</div>
          <div id="polygonSettings" style="display:none;">
            <div style="display:flex; align-items:center; gap:8px;">
              <label style="width:56px; font-size:12px;">Sides</label>
              <input type="range" id="polygonSidesInput" min="3" max="12" value="6" style="flex:1;">
              <span id="polygonSidesVal" style="width:24px; font-size:12px;">6</span>
            </div>
          </div>
          <div id="starSettings" style="display:none;">
            <div style="display:flex; align-items:center; gap:8px;">
              <label style="width:56px; font-size:12px;">Points</label>
              <input type="range" id="starPointsInput" min="3" max="12" value="5" style="flex:1;">
              <span id="starPointsVal" style="width:24px; font-size:12px;">5</span>
            </div>
            <div style="display:flex; align-items:center; gap:8px; margin-top:6px;">
              <label style="width:56px; font-size:12px;">Inner %</label>
              <input type="range" id="starInnerInput" min="10" max="90" step="5" value="50" style="flex:1;">
              <span id="starInnerVal" style="width:32px; font-size:12px;">50%</span>
            </div>
          </div>
        </div>
      </aside>
    </div>

    <script type="module">
      import init, { Graph } from "../pkg/contour_wasm.js";
      await init();
      console.log('contour demo: wasm init ok');

      const g = new Graph();
      // If saved doc exists, load it
      let loaded = false;
      try {
        // Prefer new key; fallback to legacy for backward compatibility
        const savedNew = localStorage.getItem('contour_doc');
        const savedOld = !savedNew ? localStorage.getItem('vecnet_doc') : null;
        const saved = savedNew || savedOld;
        if (saved) { loaded = g.from_json(JSON.parse(saved)); }
        // Migrate legacy key to new key after successful load
        if (loaded && savedOld) { try { localStorage.setItem('contour_doc', savedOld); } catch {} }
      } catch (e) { console.warn('Load failed', e); }
      // Start empty by default (no seeded geometry)

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      const state = {
        selection: null, // { kind: 'node'|'edge'|'text'|'shape', id }
        dragging: null,  // { id, start:[x,y], orig:[x,y] }
        connecting: null, // { startId, startPos:[x,y], cur:[x,y] }
        hover: null,     // { kind, id }
        hoverRegion: null, // { key, points }
        history: [],     // undo stack
        redo: [],        // redo stack
        snap: true,
        pen: false,
        penMode: 'points',
        bucket: false,
        regionsVersion: 0,
        regions: [],
        bend: false,
        bending: null, // { edge, t }
        penPath: null, // { startId, lastId }
        penPreview: null, // [x,y]
        freeDrawing: false,
        freePoints: null, // [x0,y0,x1,y1,...]
        edgeStyle: {}, // fallback JS-side style map: id -> { color:[r,g,b,a], width }
        svgStrokes: [], // [{ d, color:[r,g,b,a], width, cap, join }]
        svgFills: [],   // [{ d, color:[r,g,b,a], rule, transform }]
        showRef: false,
        transform: { s: 1, tx: 0, ty: 0 },
        // Text tool state
        textMode: false,
        textPending: null, // position for new text: [x, y]
        // Primitive shape tools
        rectMode: false,
        ellipseMode: false,
        polygonMode: false,
        starMode: false,
        polygonSides: 6,      // Default hexagon
        starPoints: 5,        // Default 5-point star
        starInnerRatio: 0.5,  // Inner radius as ratio of outer
        primitiveStart: null, // [x, y] drag start
        primitiveCurrent: null, // [x, y] current drag position
        // Shape/Boolean state
        shapes: [], // [{ id, edges: [...] }]
        selectedShapes: [], // [id, id] for boolean ops (max 2)
        // Multi-selection and transform state
        multiSelection: [], // Array of {kind: 'node'|'edge'|'shape'|'text', id}
        transformHandles: null, // {bbox, handles: [{x,y,type,cursor}], center}
        transformDragging: null, // {handleIndex, handle, startPoint, startBbox, startCenter}
      };

      const snapLabel = document.getElementById('snapLabel');
      const modeLabel = document.getElementById('modeLabel');
      function updateSnapLabel() {
        snapLabel.textContent = state.snap ? 'Snap: ON' : 'Snap: OFF';
      }
      function updateModeLabel() {
        let mode = 'Select/Drag';
        if (state.pen) mode = 'Pen' + (state.penMode === 'free' ? ' (Free)' : '');
        else if (state.bucket) mode = 'Bucket';
        else if (state.bend) mode = 'Bend';
        else if (state.textMode) mode = 'Text';
        else if (state.rectMode) mode = 'Rectangle';
        else if (state.ellipseMode) mode = 'Ellipse';
        else if (state.polygonMode) mode = 'Polygon (' + state.polygonSides + ')';
        else if (state.starMode) mode = 'Star (' + state.starPoints + ')';
        modeLabel.textContent = 'Mode: ' + mode;
        canvas.style.cursor = state.bucket ? 'cell' : (state.bend ? 'crosshair' : (state.pen ? 'crosshair' : (state.textMode ? 'text' : ((state.rectMode || state.ellipseMode || state.polygonMode || state.starMode) ? 'crosshair' : 'default'))));
        document.getElementById('bucketBtn').classList.toggle('active', state.bucket);
        const bendBtn = document.getElementById('bendBtn'); if (bendBtn) bendBtn.classList.toggle('active', state.bend);
        const penBtn = document.getElementById('penBtn'); if (penBtn) penBtn.classList.toggle('active', state.pen);
        const textBtn = document.getElementById('textBtn'); if (textBtn) textBtn.classList.toggle('active', state.textMode);
        const rectBtn = document.getElementById('rectBtn'); if (rectBtn) rectBtn.classList.toggle('active', state.rectMode);
        const ellipseBtn = document.getElementById('ellipseBtn'); if (ellipseBtn) ellipseBtn.classList.toggle('active', state.ellipseMode);
        const polygonBtn = document.getElementById('polygonBtn'); if (polygonBtn) polygonBtn.classList.toggle('active', state.polygonMode);
        const starBtn = document.getElementById('starBtn'); if (starBtn) starBtn.classList.toggle('active', state.starMode);
        // Show/hide primitive settings panel
        const primitiveSettings = document.getElementById('primitiveSettings');
        const polygonSettings = document.getElementById('polygonSettings');
        const starSettings = document.getElementById('starSettings');
        if (primitiveSettings) primitiveSettings.style.display = (state.polygonMode || state.starMode) ? 'flex' : 'none';
        if (polygonSettings) polygonSettings.style.display = state.polygonMode ? 'block' : 'none';
        if (starSettings) starSettings.style.display = state.starMode ? 'block' : 'none';
        // Show/hide text properties panel
        const textProps = document.getElementById('textProps');
        const shapeProps = document.getElementById('shapeProps');
        if (textProps) textProps.style.display = (state.textMode || (state.selection && state.selection.kind === 'text')) ? 'flex' : 'none';
        if (shapeProps) shapeProps.style.display = state.shapes.length > 0 ? 'flex' : 'none';
      }
      updateSnapLabel();
      updateModeLabel();

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        render();
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      // Prime regions on load
      (function(){
        const regionsVal = g.get_regions();
        try { state.regions = JSON.parse(JSON.stringify(regionsVal)); }
        catch (e) { console.warn('regions normalize failed', e, regionsVal); state.regions = []; }
        state.regionsVersion = g.geom_version();
        render();
      })();

      // Transform handle helpers
      const ROTATION_OFFSET = 25;
      const HANDLE_SIZE = 8;
      const HANDLE_HIT_TOLERANCE = 10;

      function updateTransformHandles() {
        if (state.multiSelection.length === 0) {
          state.transformHandles = null;
          return;
        }

        // Collect IDs by type
        const nodeIds = state.multiSelection.filter(s => s.kind === 'node').map(s => s.id);
        const edgeIds = state.multiSelection.filter(s => s.kind === 'edge').map(s => s.id);
        const shapeIds = state.multiSelection.filter(s => s.kind === 'shape').map(s => s.id);
        const textIds = state.multiSelection.filter(s => s.kind === 'text').map(s => s.id);

        // Get bbox from engine
        const bbox = g.get_selection_bbox(
          new Uint32Array(nodeIds),
          new Uint32Array(edgeIds),
          new Uint32Array(shapeIds),
          new Uint32Array(textIds)
        );

        if (!bbox) {
          state.transformHandles = null;
          return;
        }

        const { minx, miny, maxx, maxy } = bbox;
        const cx = (minx + maxx) / 2;
        const cy = (miny + maxy) / 2;

        state.transformHandles = {
          bbox: { minx, miny, maxx, maxy },
          center: { x: cx, y: cy },
          handles: [
            { x: minx, y: miny, type: 'scale-tl', cursor: 'nwse-resize' }, // 0: TL
            { x: maxx, y: miny, type: 'scale-tr', cursor: 'nesw-resize' }, // 1: TR
            { x: maxx, y: maxy, type: 'scale-br', cursor: 'nwse-resize' }, // 2: BR
            { x: minx, y: maxy, type: 'scale-bl', cursor: 'nesw-resize' }, // 3: BL
            { x: cx, y: miny, type: 'scale-tc', cursor: 'ns-resize' },     // 4: TC
            { x: maxx, y: cy, type: 'scale-mr', cursor: 'ew-resize' },     // 5: MR
            { x: cx, y: maxy, type: 'scale-bc', cursor: 'ns-resize' },     // 6: BC
            { x: minx, y: cy, type: 'scale-ml', cursor: 'ew-resize' },     // 7: ML
            { x: cx, y: miny - ROTATION_OFFSET, type: 'rotate', cursor: 'grab' }, // 8: Rotation
          ],
        };
      }

      function hitTestTransformHandle(x, y) {
        if (!state.transformHandles) return null;

        for (let i = 0; i < state.transformHandles.handles.length; i++) {
          const h = state.transformHandles.handles[i];
          const dx = x - h.x;
          const dy = y - h.y;
          if (dx * dx + dy * dy <= HANDLE_HIT_TOLERANCE * HANDLE_HIT_TOLERANCE) {
            return { index: i, handle: h };
          }
        }
        return null;
      }

      function commitRotation(angle) {
        const cx = state.transformHandles.center.x;
        const cy = state.transformHandles.center.y;

        const nodeIds = state.multiSelection.filter(s => s.kind === 'node').map(s => s.id);
        const edgeIds = state.multiSelection.filter(s => s.kind === 'edge').map(s => s.id);
        const textIds = state.multiSelection.filter(s => s.kind === 'text').map(s => s.id);

        // Rotate nodes and edges
        if (nodeIds.length > 0 || edgeIds.length > 0) {
          g.rotate_selection(
            new Uint32Array(nodeIds),
            new Uint32Array(edgeIds),
            cx, cy, angle
          );
        }

        // Rotate text elements
        for (const tid of textIds) {
          g.rotate_text_around(tid, cx, cy, angle);
        }

        scheduleRegions();
      }

      function commitScale(td, x, y, uniformOverride) {
        const { minx, miny, maxx, maxy } = td.startBbox;
        const w = maxx - minx || 1;
        const h = maxy - miny || 1;
        const cx = td.startCenter.x;
        const cy = td.startCenter.y;

        let sx = 1, sy = 1;
        const handle = td.handle;
        const dx = x - td.startPoint[0];
        const dy = y - td.startPoint[1];

        // Compute scale factors based on handle type
        switch (handle.type) {
          case 'scale-tl':
            sx = 1 - dx / w;
            sy = 1 - dy / h;
            break;
          case 'scale-tr':
            sx = 1 + dx / w;
            sy = 1 - dy / h;
            break;
          case 'scale-br':
            sx = 1 + dx / w;
            sy = 1 + dy / h;
            break;
          case 'scale-bl':
            sx = 1 - dx / w;
            sy = 1 + dy / h;
            break;
          case 'scale-tc':
            sy = 1 - dy / h;
            break;
          case 'scale-bc':
            sy = 1 + dy / h;
            break;
          case 'scale-ml':
            sx = 1 - dx / w;
            break;
          case 'scale-mr':
            sx = 1 + dx / w;
            break;
        }

        // Uniform scale for corners by default (shift inverts)
        if (handle.type.match(/scale-(tl|tr|br|bl)/) && !uniformOverride) {
          const avg = (Math.abs(sx) + Math.abs(sy)) / 2;
          sx = sx >= 0 ? avg : -avg;
          sy = sy >= 0 ? avg : -avg;
        }

        // Clamp to avoid degenerate transforms
        sx = Math.max(0.01, Math.abs(sx)) * Math.sign(sx || 1);
        sy = Math.max(0.01, Math.abs(sy)) * Math.sign(sy || 1);

        const nodeIds = state.multiSelection.filter(s => s.kind === 'node').map(s => s.id);
        const edgeIds = state.multiSelection.filter(s => s.kind === 'edge').map(s => s.id);
        const textIds = state.multiSelection.filter(s => s.kind === 'text').map(s => s.id);

        // Scale nodes and edges
        if (nodeIds.length > 0 || edgeIds.length > 0) {
          g.scale_selection(
            new Uint32Array(nodeIds),
            new Uint32Array(edgeIds),
            cx, cy, sx, sy, true
          );
        }

        // Scale text elements
        for (const tid of textIds) {
          g.scale_text_around(tid, cx, cy, sx, sy);
        }

        scheduleRegions();
      }

      function render() {
        const hud = document.getElementById('hud');
        try {
        // Rebuild object list if geometry changed
        try {
          const gv = g.geom_version();
          if (gv !== state.objectsVersion) { rebuildObjectList(); state.objectsVersion = gv; }
        } catch {}
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Keep properties panel in sync with selection
        refreshPropertiesPanel();

        // SVG fills imported: draw behind everything, aligned with current transform
        if (Array.isArray(state.svgFills) && state.svgFills.length > 0) {
          ctx.save();
          const t = state.transform || { s: 1, tx: 0, ty: 0 };
          ctx.translate(t.tx, t.ty);
          ctx.scale(t.s, t.s);
          for (const f of state.svgFills) {
            try {
              ctx.save();
              if (f.transform && typeof DOMMatrix === 'function') {
                const m = new DOMMatrix(String(f.transform));
                ctx.transform(m.a, m.b, m.c, m.d, m.e, m.f);
              }
              const p = new Path2D(f.d);
              const [rr,gg,bb,aa] = f.color;
              ctx.fillStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              if (typeof ctx.fill === 'function' && ctx.fill.length >= 2) ctx.fill(p, f.rule || 'nonzero'); else ctx.fill(p);
              ctx.restore();
            } catch {}
          }
          ctx.restore();
        }

        // Fills: draw behind edges (engine regions)
        const regions = state.regions;
        if (regions && Array.isArray(regions)) {
          ctx.save();
          for (const r of regions) {
            if (!r.filled) continue;
            const pts = r.points;
            if (!pts || pts.length < 6) continue;
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (let i = 2; i < pts.length; i += 2) ctx.lineTo(pts[i], pts[i+1]);
            ctx.closePath();
            // Use per-region color if present; else fallback
            if (r.color && r.color.length === 4) {
              const [rr, gg, bb, aa] = r.color;
              ctx.fillStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
            } else {
              ctx.fillStyle = 'rgba(56, 139, 253, 0.15)';
            }
            ctx.fill();
          }
          ctx.restore();
        }

        // If we have SVG stroke overlays and Ref mode is ON, draw them and return early
        if (state.showRef && state.svgStrokes && state.svgStrokes.length > 0) {
          ctx.save();
          const t = state.transform || { s: 1, tx: 0, ty: 0 };
          ctx.translate(t.tx, t.ty);
          ctx.scale(t.s, t.s);
          for (const s of state.svgStrokes) {
            try {
              const p = new Path2D(s.d);
              const [rr,gg,bb,aa] = s.color;
              ctx.strokeStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              ctx.lineWidth = s.width;
              ctx.lineCap = s.cap || 'round';
              ctx.lineJoin = s.join || 'round';
              ctx.stroke(p);
            } catch {}
          }
          ctx.restore();
          // Continue to draw engine edges/nodes underneath for clarity
        }

        // Edges (draw when reference overlay is off)
        const e = g.get_edge_data();
        const eids = e.ids; // Uint32Array
        const ep = e.endpoints; // Uint32Array [a,b,...]
        const kinds = e.kinds; // Uint8Array 0=line,1=cubic,2=polyline
        const rgba = e.stroke_rgba; // Uint8Array (4 per edge) or undefined
        const widths = e.stroke_widths; // Float32Array or undefined
        ctx.lineWidth = 2;
        for (let i = 0; i < eids.length; i++) {
          const a = ep[i*2+0];
          const b = ep[i*2+1];
          const na = g.get_node(a);
          const nb = g.get_node(b);
          if (!na || !nb) continue;
          const edgeId = eids[i];
          const selected = state.selection && state.selection.kind === 'edge' && state.selection.id === edgeId;
          const hovered = state.hover && state.hover.kind === 'edge' && state.hover.id === edgeId;
          // Base stroke style from edge typed arrays (fast, reliable)
          let baseColor = '#1f6feb';
          let baseWidth = 2;
          let cap = 'round';
          let join = 'round';
          let dash = [];
          if (rgba && widths) {
            const r = rgba[i*4+0] || 0;
            const g2 = rgba[i*4+1] || 0;
            const b2 = rgba[i*4+2] || 0;
            const a2 = rgba[i*4+3] || 0;
            const w2 = widths[i] || 0;
            if (a2 > 0 && w2 > 0) {
              baseColor = `rgba(${r}, ${g2}, ${b2}, ${Math.max(0, Math.min(1, a2/255))})`;
              baseWidth = w2;
            }
          }
          // Fallback: JS-side style map or get_edge_style if arrays indicate unset
          if (baseWidth === 2 && baseColor === '#1f6feb') {
            const jsStyle = state.edgeStyle && state.edgeStyle[edgeId];
            if (jsStyle && jsStyle.color && jsStyle.color.length === 4) {
              const [rr,gg,bb,aa] = jsStyle.color;
              baseColor = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              baseWidth = (typeof jsStyle.width === 'number' && jsStyle.width > 0) ? jsStyle.width : baseWidth;
              cap = jsStyle.cap || cap;
              join = jsStyle.join || join;
              dash = Array.isArray(jsStyle.dash) ? jsStyle.dash : dash;
            } else if (typeof g.get_edge_style === 'function') {
              try {
                const stRaw = g.get_edge_style(edgeId);
                let st = null; try { st = JSON.parse(JSON.stringify(stRaw)); } catch { st = stRaw; }
                if (st && (Array.isArray(st) ? st.length >= 5 : (st[0] !== undefined && st[4] !== undefined))) {
                  const rr = (Array.isArray(st) ? st[0] : st[0])|0;
                  const gg3 = (Array.isArray(st) ? st[1] : st[1])|0;
                  const bb3 = (Array.isArray(st) ? st[2] : st[2])|0;
                  const aa3 = (Array.isArray(st) ? st[3] : st[3])|0;
                  const ww = Array.isArray(st) ? st[4] : st[4];
                  baseColor = `rgba(${rr}, ${gg3}, ${bb3}, ${Math.max(0, Math.min(1, aa3/255))})`;
                  baseWidth = (typeof ww === 'number' && isFinite(ww) && ww > 0) ? ww : 2;
                }
              } catch {}
            }
          }

          ctx.beginPath();
          ctx.moveTo(na[0], na[1]);
          if (kinds[i] === 1) {
            const handles = g.get_handles(edgeId);
            if (handles) {
              ctx.bezierCurveTo(handles[0], handles[1], handles[2], handles[3], nb[0], nb[1]);
            } else {
              ctx.lineTo(nb[0], nb[1]);
            }
          } else if (kinds[i] === 2) {
            try {
              const pts = g.get_polyline_points(edgeId);
              const arr = Array.from(pts || []);
              for (let k = 0; k+1 < arr.length; k += 2) ctx.lineTo(arr[k], arr[k+1]);
              ctx.lineTo(nb[0], nb[1]);
            } catch { ctx.lineTo(nb[0], nb[1]); }
          } else {
            ctx.lineTo(nb[0], nb[1]);
          }
          // Use per-edge cap/join/dash if provided
          ctx.lineCap = cap;
          ctx.lineJoin = join;
          ctx.setLineDash(Array.isArray(dash) ? dash : []);
          ctx.strokeStyle = selected ? '#d73a49' : hovered ? '#2da44e' : baseColor;
          ctx.lineWidth = selected ? Math.max(4, baseWidth * 1.6) : hovered ? Math.max(3, baseWidth * 1.3) : baseWidth;
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Nodes
        const n = g.get_node_data();
        const nids = n.ids; // Uint32Array
        const pos = n.positions; // Float32Array [x,y,...]
        for (let i = 0; i < nids.length; i++) {
          const id = nids[i];
          const x = pos[i*2+0];
          const y = pos[i*2+1];
          const selected = state.selection && state.selection.kind === 'node' && state.selection.id === id;
          const hovered = state.hover && state.hover.kind === 'node' && state.hover.id === id;
          ctx.beginPath();
          ctx.arc(x, y, selected ? 6 : hovered ? 5 : 4, 0, Math.PI * 2);
          ctx.fillStyle = selected ? '#d73a49' : hovered ? '#2da44e' : '#111';
          ctx.fill();
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#fff';
          ctx.stroke();
        }

        // Handles: show for the whole connected path when an edge is selected
        if (state.selection && state.selection.kind === 'edge') {
          const ed = g.get_edge_data();
          const idsArr = Array.from(ed.ids || []);
          const endpoints = Array.from(ed.endpoints || []);
          const kinds = Array.from(ed.kinds || []);
          const selId = state.selection.id >>> 0;
          const idxSel = idsArr.indexOf(selId);
          if (idxSel >= 0) {
            // Build edge adjacency via shared nodes
            const edgesByNode = new Map();
            for (let i = 0; i < idsArr.length; i++) {
              const aId = endpoints[i*2+0];
              const bId = endpoints[i*2+1];
              if (!edgesByNode.has(aId)) edgesByNode.set(aId, []);
              if (!edgesByNode.has(bId)) edgesByNode.set(bId, []);
              edgesByNode.get(aId).push(idsArr[i]);
              edgesByNode.get(bId).push(idsArr[i]);
            }
            // BFS over edges connected via nodes (cap at safety limit)
            const comp = new Set();
            const q = [selId];
            while (q.length && comp.size < 5000) {
              const eId = q.shift();
              if (comp.has(eId)) continue;
              comp.add(eId);
              const ei = idsArr.indexOf(eId);
              if (ei < 0) continue;
              const na = endpoints[ei*2+0];
              const nb = endpoints[ei*2+1];
              const adjA = edgesByNode.get(na) || [];
              const adjB = edgesByNode.get(nb) || [];
              for (const ne of adjA) if (!comp.has(ne)) q.push(ne);
              for (const ne of adjB) if (!comp.has(ne)) q.push(ne);
            }
            // Draw handles for all cubic edges in the component
            ctx.lineWidth = 1;
            for (const eId of comp) {
              const i = idsArr.indexOf(eId);
              if (i < 0) continue;
              if (kinds[i] !== 1) continue; // only cubic
              const aId = endpoints[i*2+0];
              const bId = endpoints[i*2+1];
              const a = g.get_node(aId);
              const b = g.get_node(bId);
              const h = g.get_handles(eId);
              if (!a || !b || !h) continue;
              // stems
              ctx.beginPath();
              ctx.moveTo(a[0], a[1]); ctx.lineTo(h[0], h[1]);
              ctx.moveTo(b[0], b[1]); ctx.lineTo(h[2], h[3]);
              ctx.strokeStyle = '#999';
              ctx.setLineDash([4, 4]);
              ctx.stroke();
              ctx.setLineDash([]);
              // knobs
              for (let k = 0; k < 2; k++) {
                const hx = h[k*2+0];
                const hy = h[k*2+1];
                const hovered = state.hover && state.hover.kind === 'handle' && state.hover.edge === eId && state.hover.end === k;
                const radius = hovered ? 5 : 4;
                ctx.beginPath();
                ctx.arc(hx, hy, radius, 0, Math.PI * 2);
                ctx.fillStyle = hovered ? '#2da44e' : '#fff';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#d73a49';
                ctx.stroke();
              }
            }
          }
        }

        // Connection preview (rubber band)
        if (state.connecting) {
          const start = g.get_node(state.connecting.startId);
          if (start) {
            const [sx, sy] = start;
            const [cx, cy] = state.connecting.cur;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(cx, cy);
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }

        // Pen tool rubber band (points mode)
        if (state.pen && state.penMode === 'points' && state.penPath && state.penPreview) {
          const last = g.get_node(state.penPath.lastId);
          if (last) {
            const [sx, sy] = [last[0], last[1]];
            const [cx, cy] = state.penPreview;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(cx, cy);
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
        // Pen free-draw preview
        if (state.pen && state.penMode === 'free' && state.freeDrawing && Array.isArray(state.freePoints) && state.freePoints.length >= 4) {
          ctx.beginPath();
          ctx.moveTo(state.freePoints[0], state.freePoints[1]);
          for (let i = 2; i < state.freePoints.length; i += 2) ctx.lineTo(state.freePoints[i], state.freePoints[i+1]);
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Rectangle preview
        if (state.rectMode && state.primitiveStart && state.primitiveCurrent) {
          const [sx, sy] = state.primitiveStart;
          const [cx, cy] = state.primitiveCurrent;
          const w = cx - sx;
          const h = cy - sy;
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.strokeRect(sx, sy, w, h);
          ctx.setLineDash([]);
        }

        // Ellipse preview
        if (state.ellipseMode && state.primitiveStart && state.primitiveCurrent) {
          const [sx, sy] = state.primitiveStart;
          const [cx, cy] = state.primitiveCurrent;
          const centerX = (sx + cx) / 2;
          const centerY = (sy + cy) / 2;
          const rx = Math.abs(cx - sx) / 2;
          const ry = Math.abs(cy - sy) / 2;
          ctx.beginPath();
          ctx.ellipse(centerX, centerY, rx, ry, 0, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Polygon preview
        if (state.polygonMode && state.primitiveStart && state.primitiveCurrent) {
          const [cx, cy] = state.primitiveStart;
          const [ex, ey] = state.primitiveCurrent;
          const r = Math.hypot(ex - cx, ey - cy);
          const rotation = Math.atan2(ey - cy, ex - cx);
          const sides = state.polygonSides;
          ctx.beginPath();
          for (let i = 0; i <= sides; i++) {
            const angle = rotation + (2 * Math.PI * i) / sides;
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Star preview
        if (state.starMode && state.primitiveStart && state.primitiveCurrent) {
          const [cx, cy] = state.primitiveStart;
          const [ex, ey] = state.primitiveCurrent;
          const rOuter = Math.hypot(ex - cx, ey - cy);
          const rInner = rOuter * state.starInnerRatio;
          const rotation = Math.atan2(ey - cy, ex - cx);
          const points = state.starPoints;
          const totalVerts = points * 2;
          ctx.beginPath();
          for (let i = 0; i <= totalVerts; i++) {
            const angle = rotation + (2 * Math.PI * i) / totalVerts;
            const radius = (i % 2 === 0) ? rOuter : rInner;
            const x = cx + radius * Math.cos(angle);
            const y = cy + radius * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Text elements rendering
        try {
          if (typeof g.get_text_ids === 'function') {
            const textIds = g.get_text_ids();
            if (textIds && textIds.length > 0) {
              for (let i = 0; i < textIds.length; i++) {
                const tid = textIds[i];
                const tdata = g.get_text(tid);
                if (!tdata) continue;
                const isSelected = state.selection && state.selection.kind === 'text' && state.selection.id === tid;
                const tx = tdata.position ? tdata.position.x : 0;
                const ty = tdata.position ? tdata.position.y : 0;
                const style = tdata.style || {};
                const fontSize = style.font_size || 16;
                const fontWeight = style.font_weight || 400;
                const fontFamily = style.font_family || 'sans-serif';
                ctx.save();
                ctx.translate(tx, ty);
                if (tdata.rotation) ctx.rotate(tdata.rotation);
                ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
                ctx.textBaseline = 'top';
                const alignVal = typeof tdata.align === 'number' ? tdata.align : (tdata.align === 'Center' ? 1 : tdata.align === 'Right' ? 2 : 0);
                ctx.textAlign = alignVal === 1 ? 'center' : alignVal === 2 ? 'right' : 'left';
                // Fill color
                if (style.fill_color) {
                  const fc = style.fill_color;
                  ctx.fillStyle = `rgba(${fc.r || 0},${fc.g || 0},${fc.b || 0},${(fc.a || 255)/255})`;
                } else {
                  ctx.fillStyle = '#000';
                }
                ctx.fillText(tdata.content || '', 0, 0);
                // Selection highlight
                if (isSelected) {
                  const metrics = ctx.measureText(tdata.content || '');
                  const h = fontSize;
                  ctx.strokeStyle = '#d73a49';
                  ctx.lineWidth = 1;
                  ctx.setLineDash([3, 3]);
                  ctx.strokeRect(-2, -2, metrics.width + 4, h + 4);
                  ctx.setLineDash([]);
                }
                ctx.restore();
              }
            }
          }
        } catch (e) { console.warn('Text render error:', e); }

        // Shape outlines (highlight selected shapes for boolean ops)
        if (state.selectedShapes.length > 0) {
          const colors = ['#e63946', '#457b9d'];
          for (let si = 0; si < state.selectedShapes.length; si++) {
            const shapeId = state.selectedShapes[si];
            try {
              const shapeEdges = g.get_shape_edges(shapeId);
              if (shapeEdges && shapeEdges.length > 0) {
                ctx.save();
                ctx.strokeStyle = colors[si % 2];
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                for (let j = 0; j < shapeEdges.length; j++) {
                  const eid = shapeEdges[j];
                  const ed = g.get_edge_data();
                  const idx = Array.from(ed.ids).indexOf(eid);
                  if (idx < 0) continue;
                  const aId = ed.endpoints[idx*2+0];
                  const bId = ed.endpoints[idx*2+1];
                  const a = g.get_node(aId);
                  const b = g.get_node(bId);
                  if (!a || !b) continue;
                  ctx.beginPath();
                  ctx.moveTo(a[0], a[1]);
                  if (ed.kinds[idx] === 1) {
                    const h = g.get_handles(eid);
                    if (h) ctx.bezierCurveTo(h[0], h[1], h[2], h[3], b[0], b[1]);
                    else ctx.lineTo(b[0], b[1]);
                  } else {
                    ctx.lineTo(b[0], b[1]);
                  }
                  ctx.stroke();
                }
                ctx.setLineDash([]);
                ctx.restore();
              }
            } catch {}
          }
        }

        // Transform bounding box and handles
        if (state.transformHandles && state.multiSelection.length > 0) {
          const th = state.transformHandles;
          const { minx, miny, maxx, maxy } = th.bbox;

          ctx.save();
          // Draw bounding box
          ctx.strokeStyle = '#1a73e8';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          ctx.strokeRect(minx, miny, maxx - minx, maxy - miny);
          ctx.setLineDash([]);

          // Draw connection line from rotation handle to top-center
          ctx.beginPath();
          ctx.moveTo(th.handles[8].x, th.handles[8].y);
          ctx.lineTo(th.handles[4].x, th.handles[4].y);
          ctx.stroke();

          // Draw handles
          for (let i = 0; i < th.handles.length; i++) {
            const h = th.handles[i];
            ctx.beginPath();

            if (h.type === 'rotate') {
              // Rotation handle: filled circle
              ctx.arc(h.x, h.y, HANDLE_SIZE / 2, 0, Math.PI * 2);
              ctx.fillStyle = '#1a73e8';
              ctx.fill();
            } else {
              // Scale handles: white squares with blue border
              ctx.rect(h.x - HANDLE_SIZE / 2, h.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
              ctx.fillStyle = '#fff';
              ctx.strokeStyle = '#1a73e8';
              ctx.lineWidth = 2;
              ctx.fill();
              ctx.stroke();
            }
          }
          ctx.restore();
        }

        // HUD update
        try {
          const ecount = (eids && eids.length)|0; const ncount = (nids && nids.length)|0;
          if (hud) hud.textContent = `nodes: ${ncount} | edges: ${ecount} | ref: ${state.showRef?'on':'off'}`;
        } catch { if (hud) hud.textContent = 'hud update failed'; }
        } catch (err) {
          console.error('render error', err);
          if (hud) hud.textContent = 'render error: ' + (err && err.message ? err.message : String(err));
        }
      }

      // --- Properties panel (per-edge stroke controls) ---
      function ensurePropertiesPanel() {
        const props = document.getElementById('props'); if (!props) return;
        if (props.dataset.built === '1') return;
        props.dataset.built = '1';
        props.innerHTML = '';
        // Title row updates dynamically
        const title = document.createElement('div');
        title.id = 'propsTitle';
        title.style.cssText = 'font-size:12px; color:#555;';
        props.appendChild(title);

        // Color + Opacity
        const colorRow = document.createElement('div');
        colorRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const colorLabel = document.createElement('div'); colorLabel.textContent = 'Stroke'; colorLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.id = 'strokeColor'; colorInput.style.cssText = 'flex:0 0 auto; width:36px; height:24px; padding:0; border:none; background:none;';
        const opacityInput = document.createElement('input'); opacityInput.type = 'range'; opacityInput.min = '0'; opacityInput.max = '100'; opacityInput.step = '1'; opacityInput.id = 'strokeOpacity'; opacityInput.style.cssText = 'flex:1;';
        const opacityVal = document.createElement('div'); opacityVal.id = 'strokeOpacityVal'; opacityVal.style.cssText = 'width:36px; text-align:right; font-size:12px; color:#555;';
        colorRow.appendChild(colorLabel); colorRow.appendChild(colorInput); colorRow.appendChild(opacityInput); colorRow.appendChild(opacityVal);
        props.appendChild(colorRow);

        // Width
        const widthRow = document.createElement('div'); widthRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const widthLabel = document.createElement('div'); widthLabel.textContent = 'Width'; widthLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const widthInput = document.createElement('input'); widthInput.type = 'range'; widthInput.min = '0.5'; widthInput.max = '20'; widthInput.step = '0.5'; widthInput.id = 'strokeWidth'; widthInput.style.cssText = 'flex:1;';
        const widthVal = document.createElement('div'); widthVal.id = 'strokeWidthVal'; widthVal.style.cssText = 'width:36px; text-align:right; font-size:12px; color:#555;';
        widthRow.appendChild(widthLabel); widthRow.appendChild(widthInput); widthRow.appendChild(widthVal);
        props.appendChild(widthRow);

        // Line Cap
        const capRow = document.createElement('div'); capRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const capLabel = document.createElement('div'); capLabel.textContent = 'Cap'; capLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const capSelect = document.createElement('select'); capSelect.id = 'lineCap'; capSelect.style.cssText = 'flex:1;';
        ['round','butt','square'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; capSelect.appendChild(o); });
        capRow.appendChild(capLabel); capRow.appendChild(capSelect); props.appendChild(capRow);

        // Line Join
        const joinRow = document.createElement('div'); joinRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const joinLabel = document.createElement('div'); joinLabel.textContent = 'Join'; joinLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const joinSelect = document.createElement('select'); joinSelect.id = 'lineJoin'; joinSelect.style.cssText = 'flex:1;';
        ['round','bevel','miter'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; joinSelect.appendChild(o); });
        joinRow.appendChild(joinLabel); joinRow.appendChild(joinSelect); props.appendChild(joinRow);

        // Line Dash
        const dashRow = document.createElement('div'); dashRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const dashLabel = document.createElement('div'); dashLabel.textContent = 'Dash'; dashLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const dashPreset = document.createElement('select'); dashPreset.id = 'lineDashPreset'; dashPreset.style.cssText = 'flex:0 0 90px;';
        [['','Solid'],['5,5','Dashed'],['2,6','Dotted'],['custom','Custom']].forEach(([val,lab])=>{ const o=document.createElement('option'); o.value=val; o.textContent=lab; dashPreset.appendChild(o); });
        const dashInput = document.createElement('input'); dashInput.type = 'text'; dashInput.placeholder = 'e.g. 6,4'; dashInput.id = 'lineDash'; dashInput.style.cssText = 'flex:1;';
        dashRow.appendChild(dashLabel); dashRow.appendChild(dashPreset); dashRow.appendChild(dashInput); props.appendChild(dashRow);

        const applyFromUI = () => {
          const sel = state.selection;
          if (!sel || sel.kind !== 'edge') return;
          const id = sel.id >>> 0;
          const hex = document.getElementById('strokeColor').value || '#1f6feb';
          const op = parseInt(document.getElementById('strokeOpacity').value || '100', 10);
          const w = parseFloat(document.getElementById('strokeWidth').value || '2');
          const [r_,g_,b_] = hexToRgb(hex);
          const a = Math.max(0, Math.min(255, Math.round((op/100) * 255)));
          try { if (typeof g.set_edge_style === 'function') { g.set_edge_style(id, r_|0, g_|0, b_|0, a|0, isFinite(w) ? w : 2); } } catch {}
          // Cap, join, dash (JS-side persistence)
          const cap = (document.getElementById('lineCap').value || 'round');
          const join = (document.getElementById('lineJoin').value || 'round');
          let dash = [];
          const preset = document.getElementById('lineDashPreset').value;
          const dashStr = document.getElementById('lineDash').value;
          if (preset === 'custom') {
            dash = parseDash(dashStr);
          } else if (preset) {
            dash = parseDash(preset);
          }
          state.edgeStyle[id] = { color: [r_|0, g_|0, b_|0, a|0], width: isFinite(w) ? w : 2, cap, join, dash };
          render();
        };
        colorInput.addEventListener('input', applyFromUI);
        opacityInput.addEventListener('input', () => { document.getElementById('strokeOpacityVal').textContent = (parseInt(opacityInput.value,10) || 0) + '%'; applyFromUI(); });
        widthInput.addEventListener('input', () => { document.getElementById('strokeWidthVal').textContent = (parseFloat(widthInput.value)||0).toFixed(1); applyFromUI(); });
        capSelect.addEventListener('change', applyFromUI);
        joinSelect.addEventListener('change', applyFromUI);
        dashPreset.addEventListener('change', () => {
          const v = dashPreset.value;
          if (v === 'custom') {
            dashInput.disabled = false;
          } else {
            dashInput.disabled = true;
          }
          applyFromUI();
        });
        dashInput.addEventListener('input', applyFromUI);
      }

      function hexToRgb(hex) {
        const v = String(hex||'').trim();
        const h = v[0] === '#' ? v.slice(1) : v;
        const n = h.length === 3 ? h.split('').map(c=>c+c).join('') : h;
        if (!/^[0-9a-fA-F]{6}$/.test(n)) return [31,111,235];
        const x = parseInt(n, 16);
        const r = (x>>16)&255, g = (x>>8)&255, b = x&255;
        return [r,g,b];
      }

      function rgbToHex(r,g,b) {
        const h = (n) => n.toString(16).padStart(2, '0');
        return '#' + h(r) + h(g) + h(b);
      }

      function parseDash(s) {
        if (!s) return [];
        return String(s).split(',').map(x => parseFloat(x.trim())).filter(n => isFinite(n) && n > 0);
      }

      function refreshPropertiesPanel() {
        ensurePropertiesPanel();
        const props = document.getElementById('props'); if (!props) return;
        const title = document.getElementById('propsTitle');
        const sel = state.selection;
        if (!sel || sel.kind !== 'edge') {
          if (title) title.textContent = 'No selection';
          // Disable inputs when no selection
          const inputs = props.querySelectorAll('input'); inputs.forEach(i => i.disabled = true);
          return;
        }
        // Enable inputs
        const inputs = props.querySelectorAll('input'); inputs.forEach(i => i.disabled = false);
        const id = sel.id >>> 0;
        if (title) title.textContent = `Path ${id}`;
        // Resolve style from engine first, fallback to JS map, else defaults
        let r=31,gc=111,b=235,a=255,w=2;
        try {
          const st = g.get_edge_style(id);
          let arr = null; try { arr = JSON.parse(JSON.stringify(st)); } catch { arr = st; }
          if (arr && arr.length >= 5) {
            r = (arr[0]|0)>>>0; gc = (arr[1]|0)>>>0; b = (arr[2]|0)>>>0; a = (arr[3]|0)>>>0; w = (typeof arr[4]==='number'&&isFinite(arr[4]))?arr[4]:2;
          }
        } catch {}
        if ((w === 2 && r===31 && gc===111 && b===235 && a===255) && state.edgeStyle && state.edgeStyle[id]) {
          const st = state.edgeStyle[id];
          if (st && st.color) { r = st.color[0]|0; gc = st.color[1]|0; b = st.color[2]|0; a = st.color[3]|0; }
          if (st && typeof st.width === 'number') w = st.width;
        }
        // Populate UI values
        const colorEl = document.getElementById('strokeColor');
        const opEl = document.getElementById('strokeOpacity');
        const opVal = document.getElementById('strokeOpacityVal');
        const wEl = document.getElementById('strokeWidth');
        const wVal = document.getElementById('strokeWidthVal');
        if (colorEl) colorEl.value = rgbToHex(r,gc,b);
        const pct = Math.round(Math.max(0, Math.min(1, (a||255)/255)) * 100);
        if (opEl) opEl.value = String(pct);
        if (opVal) opVal.textContent = pct + '%';
        if (wEl) wEl.value = String(isFinite(w)?w:2);
        if (wVal) wVal.textContent = (isFinite(w)?w:2).toFixed(1);
        // Cap/Join/Dash
        const capEl = document.getElementById('lineCap');
        const joinEl = document.getElementById('lineJoin');
        const dashPreset = document.getElementById('lineDashPreset');
        const dashEl = document.getElementById('lineDash');
        let cap = 'round', join = 'round', dash = [];
        const jsStyle = state.edgeStyle && state.edgeStyle[id];
        if (jsStyle) {
          cap = jsStyle.cap || cap;
          join = jsStyle.join || join;
          dash = Array.isArray(jsStyle.dash) ? jsStyle.dash.slice() : dash;
        }
        if (capEl) capEl.value = cap;
        if (joinEl) joinEl.value = join;
        if (dash && dash.length) { if (dashPreset) dashPreset.value = 'custom'; if (dashEl) { dashEl.disabled = false; dashEl.value = dash.join(','); } }
        else { if (dashPreset) dashPreset.value = ''; if (dashEl) { dashEl.disabled = true; dashEl.value = ''; } }
      }

      // Regions: recompute at most once per animation frame
      state.scheduledRegion = false;
      function scheduleRegions() {
        if (state.scheduledRegion) return;
        state.scheduledRegion = true;
        requestAnimationFrame(() => {
          state.scheduledRegion = false;
          const ver = g.geom_version();
          if (ver === state.regionsVersion) return;
          const regionsVal = g.get_regions();
          try { state.regions = JSON.parse(JSON.stringify(regionsVal)); }
          catch (e) { console.warn('regions normalize failed', e, regionsVal); state.regions = []; }
          state.regionsVersion = ver;
          render();
        });
      }

      function canvasPoint(evt) {
        const rect = canvas.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        return [x, y];
      }

      const GRID = 10;
      function snapPoint(x, y, excludeNodeId = null) {
        if (!state.snap) return [x, y];
        // Grid snap first
        let sx = Math.round(x / GRID) * GRID;
        let sy = Math.round(y / GRID) * GRID;
        // Snap to nearest node within radius
        const data = g.get_node_data();
        const ids = data.ids;
        const pos = data.positions;
        let bestId = null;
        let bestD2 = 12*12; // radius
        for (let i = 0; i < ids.length; i++) {
          const id = ids[i];
          if (excludeNodeId !== null && id === excludeNodeId) continue;
          const nx = pos[i*2+0];
          const ny = pos[i*2+1];
          const dx = nx - sx; const dy = ny - sy;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestD2) { bestD2 = d2; bestId = id; }
        }
        if (bestId !== null) {
          const n = g.get_node(bestId);
          if (n) { sx = n[0]; sy = n[1]; }
        }
        return [sx, sy];
      }

      canvas.addEventListener('mousedown', (evt) => {
        // Defensive: ensure Graph is usable
        if (!g || typeof g.get_edge_data !== 'function') { console.error('Graph not ready'); return; }
        const [x, y] = canvasPoint(evt);

        // Check for transform handle hit first (before normal picking)
        if (state.transformHandles) {
          const handleHit = hitTestTransformHandle(x, y);
          if (handleHit) {
            state.transformDragging = {
              handleIndex: handleHit.index,
              handle: handleHit.handle,
              startPoint: [x, y],
              startBbox: { ...state.transformHandles.bbox },
              startCenter: { ...state.transformHandles.center },
            };
            return;
          }
        }

        // Pen tool interactions
        if (state.pen && state.penMode === 'points') {
          const [sx, sy] = snapPoint(x, y, null);
          const pickP = g.pick(sx, sy, 8);
          if (!state.penPath) {
            // Start path
            if (pickP && pickP.kind === 'node') {
              const id = pickP.id >>> 0;
              state.penPath = { startId: id, lastId: id };
            } else {
              const nid = g.add_node(sx, sy);
              state.penPath = { startId: nid, lastId: nid };
            }
            state.penPreview = [sx, sy];
            render();
            return;
          } else {
            // Extend path
            let targetId = null;
            if (pickP && pickP.kind === 'node') {
              targetId = pickP.id >>> 0;
            } else {
              targetId = g.add_node(sx, sy);
            }
            if (targetId != null && targetId !== state.penPath.lastId) {
              g.add_edge(state.penPath.lastId, targetId);
              state.penPath.lastId = targetId;
              scheduleRegions();
            }
            state.penPreview = [sx, sy];
            render();
            return;
          }
        }
        // Pen free draw: start stroke
        if (state.pen && state.penMode === 'free') {
          // Freehand uses raw pointer positions (no snapping)
          state.freeDrawing = true;
          state.freePoints = [x, y];
          render();
          return;
        }

        const pick = g.pick(x, y, 10);
        if (state.bend && pick && pick.kind === 'edge') {
          state.bending = { edge: pick.id >>> 0, t: pick.t ?? 0.5 };
          return;
        }
        if (state.bucket && (!pick || !pick.kind)) {
          // Paint bucket: toggle the region under cursor
          const regions = state.regions;
          let hit = null;
          const list = Array.isArray(regions) ? regions : [];
          for (const r of list) {
            if (pointInPoly(x, y, r.points)) { hit = r; break; }
          }
          if (hit) {
            const after = g.toggle_region(hit.key >>> 0);
            for (const r of state.regions) { if (r.key === hit.key) { r.filled = after; break; } }
            console.log('Toggled region', hit.key, 'filled:', after);
            render();
          } else {
            console.log('No region under cursor at', x, y);
          }
          return;
        }

        // Rectangle tool: start drag
        if (state.rectMode) {
          const [sx, sy] = snapPoint(x, y, null);
          state.primitiveStart = [sx, sy];
          state.primitiveCurrent = [sx, sy];
          render();
          return;
        }

        // Ellipse tool: start drag
        if (state.ellipseMode) {
          const [sx, sy] = snapPoint(x, y, null);
          state.primitiveStart = [sx, sy];
          state.primitiveCurrent = [sx, sy];
          render();
          return;
        }

        // Polygon tool: start drag (center at click, drag to set radius and rotation)
        if (state.polygonMode) {
          const [sx, sy] = snapPoint(x, y, null);
          state.primitiveStart = [sx, sy];
          state.primitiveCurrent = [sx, sy];
          render();
          return;
        }

        // Star tool: start drag (center at click, drag to set radius and rotation)
        if (state.starMode) {
          const [sx, sy] = snapPoint(x, y, null);
          state.primitiveStart = [sx, sy];
          state.primitiveCurrent = [sx, sy];
          render();
          return;
        }

        // Text tool: click to add text or select existing text
        if (state.textMode) {
          // Check if clicking on existing text
          let clickedText = null;
          try {
            if (typeof g.get_text_ids === 'function') {
              const textIds = g.get_text_ids();
              for (let i = 0; textIds && i < textIds.length; i++) {
                const tid = textIds[i];
                const tdata = g.get_text(tid);
                if (!tdata) continue;
                // Simple bbox hit test
                const tx = tdata.position ? tdata.position.x : 0;
                const ty = tdata.position ? tdata.position.y : 0;
                const style = tdata.style || {};
                const fs = style.font_size || 16;
                ctx.font = `${style.font_weight || 400} ${fs}px ${style.font_family || 'sans-serif'}`;
                const tw = ctx.measureText(tdata.content || '').width;
                if (x >= tx - 5 && x <= tx + tw + 5 && y >= ty - 5 && y <= ty + fs + 5) {
                  clickedText = tid;
                  break;
                }
              }
            }
          } catch (e) { console.warn('Text hit test error:', e); }

          if (clickedText !== null) {
            // Select existing text
            state.selection = { kind: 'text', id: clickedText };
            refreshTextPropertiesPanel();
            updateModeLabel();
            render();
          } else {
            // Add new text at click position
            const defaultText = 'Text';
            if (typeof g.add_text === 'function') {
              const newId = g.add_text(defaultText, x, y);
              state.selection = { kind: 'text', id: newId };
              refreshTextPropertiesPanel();
              updateModeLabel();
              render();
              console.log('Added text at', x, y, 'id:', newId);
            }
          }
          return;
        }

        if (pick && pick.kind === 'node') {
          const id = pick.id >>> 0;
          const n = g.get_node(id);
          const selItem = { kind: 'node', id };

          if (evt.shiftKey) {
            // Add/remove from multi-selection
            const idx = state.multiSelection.findIndex(s => s.kind === 'node' && s.id === id);
            if (idx >= 0) {
              state.multiSelection.splice(idx, 1);
            } else {
              state.multiSelection.push(selItem);
            }
          } else {
            // Replace selection
            state.multiSelection = [selItem];
          }
          state.selection = state.multiSelection[0] || null;
          updateTransformHandles();

          if (evt.altKey) {
            // Start connecting mode
            state.connecting = { startId: id, startPos: [n[0], n[1]], cur: [x, y] };
            state.dragging = null;
          } else {
            // Drag node
            state.dragging = { id, start: [x, y], orig: [n[0], n[1]] };
          }
        } else if (pick && pick.kind === 'handle') {
          const edge = pick.edge >>> 0;
          const end = pick.end >>> 0;
          state.selection = { kind: 'edge', id: edge };
          state.dragging = { handle: true, edge, end };
        } else if (pick && pick.kind === 'edge') {
          const id = pick.id >>> 0;
          const selItem = { kind: 'edge', id };

          if (evt.shiftKey) {
            const idx = state.multiSelection.findIndex(s => s.kind === 'edge' && s.id === id);
            if (idx >= 0) {
              state.multiSelection.splice(idx, 1);
            } else {
              state.multiSelection.push(selItem);
            }
          } else {
            state.multiSelection = [selItem];
          }
          state.selection = state.multiSelection[0] || null;
          updateTransformHandles();
          state.dragging = null;
        } else {
          if (!evt.shiftKey) {
            state.multiSelection = [];
            state.transformHandles = null;
          }
          state.selection = null;
          state.dragging = null;
        }
        render();
      });

      window.addEventListener('mousemove', (evt) => {
        const [x, y] = canvasPoint(evt);

        // Transform handle dragging
        if (state.transformDragging) {
          const td = state.transformDragging;

          if (td.handle.type === 'rotate') {
            // Update cursor for rotation
            canvas.style.cursor = 'grabbing';
          } else {
            canvas.style.cursor = td.handle.cursor;
          }
          render();
          return;
        }

        // Update cursor when hovering over transform handles
        if (state.transformHandles && !state.dragging && !state.connecting) {
          const handleHit = hitTestTransformHandle(x, y);
          if (handleHit) {
            canvas.style.cursor = handleHit.handle.cursor;
          }
        }

        // Rectangle/Ellipse/Polygon/Star drag preview
        if ((state.rectMode || state.ellipseMode || state.polygonMode || state.starMode) && state.primitiveStart) {
          const [sx, sy] = snapPoint(x, y, null);
          state.primitiveCurrent = [sx, sy];
          render();
          return;
        }
        if (state.pen && state.penMode === 'points' && state.penPath) {
          const [sx, sy] = snapPoint(x, y, null);
          state.penPreview = [sx, sy];
          render();
          return;
        }
        if (state.pen && state.penMode === 'free' && state.freeDrawing) {
          // Freehand sampling in raw screen space for smoothness
          const sx = x, sy = y;
          const pts = state.freePoints || [];
          const n = pts.length;
          const lx = pts[n-2], ly = pts[n-1];
          const dx = sx - lx, dy = sy - ly;
          const d2 = dx*dx + dy*dy;
          if (d2 >= 9) { // sample every ~3px
            pts.push(sx, sy);
            state.freePoints = pts;
            render();
          }
          return;
        }
        if (state.bending) {
          const { edge, t } = state.bending;
          const [sx, sy] = snapPoint(x, y, null);
          g.bend_edge_to(edge, t, sx, sy, 1.0);
          scheduleRegions();
          render();
          return;
        }
        // Bucket hover detection
        if (state.bucket && !state.dragging && !state.connecting) {
          const regions = state.regions;
          let found = null;
          if (Array.isArray(regions)) {
            for (const r of regions) { if (pointInPoly(x, y, r.points)) { found = r; break; } }
          }
          state.hoverRegion = found;
          render();
        } else {
          state.hoverRegion = null;
        }
        // Hover update when idle
        if (!state.dragging && !state.connecting) {
          const h = g.pick(x, y, 10);
          if (h && h.kind === 'handle') {
            state.hover = { kind: 'handle', edge: h.edge >>> 0, end: h.end >>> 0 };
          } else if (h && h.kind) {
            state.hover = { kind: h.kind, id: h.id >>> 0 };
          } else {
            state.hover = null;
          }
        }
        // Connecting preview
        if (state.connecting) {
          const s = state.connecting;
          const snapped = snapPoint(x, y, s.startId);
          s.cur = snapped;
          render();
          return;
        }
        if (!state.dragging) return;
        if (state.dragging.handle) {
          const { edge, end } = state.dragging;
          const [sx, sy] = snapPoint(x, y, null);
          g.set_handle_pos(edge, end, sx, sy);
          scheduleRegions();
          render();
        } else {
          const snapped = snapPoint(x, y, state.dragging.id);
          const { id } = state.dragging;
          g.move_node(id, snapped[0], snapped[1]);
          scheduleRegions();
          render();
        }
      });

      window.addEventListener('mouseup', (evt) => {
        if (state.bending) { state.bending = null; return; }
        const [x, y] = canvasPoint(evt);

        // Finish transform dragging
        if (state.transformDragging) {
          const td = state.transformDragging;

          if (td.handle.type === 'rotate') {
            // Calculate rotation angle
            const cx = td.startCenter.x;
            const cy = td.startCenter.y;
            const startAngle = Math.atan2(td.startPoint[1] - cy, td.startPoint[0] - cx);
            const currentAngle = Math.atan2(y - cy, x - cx);
            const deltaAngle = currentAngle - startAngle;

            if (Math.abs(deltaAngle) > 0.001) {
              commitRotation(deltaAngle);
            }
          } else {
            // Commit scale
            commitScale(td, x, y, evt.shiftKey);
          }

          state.transformDragging = null;
          updateTransformHandles();
          canvas.style.cursor = 'default';
          render();
          return;
        }

        // Finish rectangle on mouseup
        if (state.rectMode && state.primitiveStart) {
          const [sx, sy] = state.primitiveStart;
          const [ex, ey] = snapPoint(x, y, null);
          state.primitiveStart = null;
          state.primitiveCurrent = null;
          const w = ex - sx;
          const h = ey - sy;
          // Only create if there's a meaningful size
          if (Math.abs(w) > 2 && Math.abs(h) > 2) {
            try {
              const minX = Math.min(sx, ex);
              const minY = Math.min(sy, ey);
              const result = g.add_rectangle(minX, minY, Math.abs(w), Math.abs(h), 0);
              console.log('Created rectangle:', result);
              if (result && result.edges && result.edges.length > 0) {
                state.selection = { kind: 'edge', id: result.edges[0] };
              }
              scheduleRegions();
            } catch (e) { console.error('Rectangle creation failed:', e); }
          }
          render();
          return;
        }

        // Finish ellipse on mouseup
        if (state.ellipseMode && state.primitiveStart) {
          const [sx, sy] = state.primitiveStart;
          const [ex, ey] = snapPoint(x, y, null);
          state.primitiveStart = null;
          state.primitiveCurrent = null;
          const rx = Math.abs(ex - sx) / 2;
          const ry = Math.abs(ey - sy) / 2;
          // Only create if there's a meaningful size
          if (rx > 2 && ry > 2) {
            try {
              const cx = (sx + ex) / 2;
              const cy = (sy + ey) / 2;
              const result = g.add_ellipse(cx, cy, rx, ry);
              console.log('Created ellipse:', result);
              if (result && result.edges && result.edges.length > 0) {
                state.selection = { kind: 'edge', id: result.edges[0] };
              }
              scheduleRegions();
            } catch (e) { console.error('Ellipse creation failed:', e); }
          }
          render();
          return;
        }

        // Finish polygon on mouseup
        if (state.polygonMode && state.primitiveStart) {
          const [cx, cy] = state.primitiveStart;
          const [ex, ey] = snapPoint(x, y, null);
          state.primitiveStart = null;
          state.primitiveCurrent = null;
          const r = Math.hypot(ex - cx, ey - cy);
          // Only create if there's a meaningful size
          if (r > 2) {
            try {
              const rotation = Math.atan2(ey - cy, ex - cx);
              const result = g.add_polygon(cx, cy, r, state.polygonSides, rotation);
              console.log('Created polygon:', result);
              if (result && result.edges && result.edges.length > 0) {
                state.selection = { kind: 'edge', id: result.edges[0] };
              }
              scheduleRegions();
            } catch (e) { console.error('Polygon creation failed:', e); }
          }
          render();
          return;
        }

        // Finish star on mouseup
        if (state.starMode && state.primitiveStart) {
          const [cx, cy] = state.primitiveStart;
          const [ex, ey] = snapPoint(x, y, null);
          state.primitiveStart = null;
          state.primitiveCurrent = null;
          const rOuter = Math.hypot(ex - cx, ey - cy);
          const rInner = rOuter * state.starInnerRatio;
          // Only create if there's a meaningful size
          if (rOuter > 2) {
            try {
              const rotation = Math.atan2(ey - cy, ex - cx);
              const result = g.add_star(cx, cy, rOuter, rInner, state.starPoints, rotation);
              console.log('Created star:', result);
              if (result && result.edges && result.edges.length > 0) {
                state.selection = { kind: 'edge', id: result.edges[0] };
              }
              scheduleRegions();
            } catch (e) { console.error('Star creation failed:', e); }
          }
          render();
          return;
        }

        // Finish free draw on mouseup
        if (state.pen && state.penMode === 'free' && state.freeDrawing) {
          const pts = Array.isArray(state.freePoints) ? state.freePoints.slice() : [];
          state.freeDrawing = false; state.freePoints = null;
          if (pts.length >= 4) {
            // Optionally close if end near start
            const dx = pts[pts.length-2] - pts[0];
            const dy = pts[pts.length-1] - pts[1];
            const close = (dx*dx + dy*dy) <= 12*12;
            try {
              if (typeof g.add_freehand === 'function') {
                g.add_freehand(new Float32Array(pts), !!close);
              } else {
                // Fallback: simple polyline if freehand API missing
                const startId = g.add_node(pts[0], pts[1]);
                const endId = g.add_node(pts[pts.length-2], pts[pts.length-1]);
                const internal = pts.slice(2, pts.length-2);
                if (typeof g.add_polyline_edge === 'function') g.add_polyline_edge(startId, endId, new Float32Array(internal));
              }
            } catch {}
            scheduleRegions();
            render();
          }
          return;
        }
        if (state.connecting) {
          const s = state.connecting; state.connecting = null;
          // If mouse up over a node, connect them
          const p = g.pick(x, y, 10);
          if (p && p.kind === 'node') {
            const endId = p.id >>> 0;
            if (endId !== s.startId) {
              g.add_edge(s.startId, endId);
              scheduleRegions();
            }
          }
          render();
          return;
        }
        if (!state.dragging) return;
        if (state.dragging.handle) {
          state.dragging = null;
        } else {
          const { id, orig } = state.dragging;
          state.dragging = null;
          const after = g.get_node(id);
          if (after && (after[0] !== orig[0] || after[1] !== orig[1])) {
            state.history.push({
              type: 'move_node', id,
              before: orig.slice(), after: [after[0], after[1]]
            });
            state.redo.length = 0; // clear redo on new action
          }
        }
      });

      // Copy/Paste functionality
      const PASTE_OFFSET = 15;

      async function copySelection() {
        if (!state.selection) return;
        const payload = { type: 'contour-clipboard', version: 1, element: null };

        switch (state.selection.kind) {
          case 'node': {
            const pos = g.get_node(state.selection.id);
            if (!pos) return;
            payload.element = { kind: 'node', x: pos[0], y: pos[1] };
            break;
          }
          case 'edge': {
            const ed = g.get_edge_data();
            const idx = Array.from(ed.ids).indexOf(state.selection.id);
            if (idx < 0) return;

            const aId = ed.endpoints[idx * 2];
            const bId = ed.endpoints[idx * 2 + 1];
            const nodeA = g.get_node(aId);
            const nodeB = g.get_node(bId);
            if (!nodeA || !nodeB) return;

            // Determine edge kind and get details
            let edgeKind = 'line';
            const kindVal = ed.kinds[idx];
            if (kindVal === 1) {
              // Cubic edge - get handles
              const handles = g.get_handles(state.selection.id);
              if (handles) {
                edgeKind = {
                  cubic: {
                    ha: { x: handles[0] - nodeA[0], y: handles[1] - nodeA[1] },
                    hb: { x: handles[2] - nodeB[0], y: handles[3] - nodeB[1] },
                    mode: g.get_handle_mode ? g.get_handle_mode(state.selection.id) || 0 : 0
                  }
                };
              }
            } else if (kindVal === 2 && g.get_polyline_points) {
              // Polyline edge
              const pts = g.get_polyline_points(state.selection.id);
              if (pts && pts.length > 0) {
                const points = [];
                for (let i = 0; i < pts.length; i += 2) {
                  points.push({ x: pts[i], y: pts[i + 1] });
                }
                edgeKind = { polyline: { points } };
              }
            }

            // Get stroke style
            let stroke = null;
            let strokeWidth = 2;
            if (ed.stroke_rgba && ed.stroke_widths) {
              const r = ed.stroke_rgba[idx * 4];
              const gg = ed.stroke_rgba[idx * 4 + 1];
              const b = ed.stroke_rgba[idx * 4 + 2];
              const a = ed.stroke_rgba[idx * 4 + 3];
              strokeWidth = ed.stroke_widths[idx] || 2;
              if (a > 0) {
                stroke = [r, gg, b, a];
              }
            }

            payload.element = {
              kind: 'edge',
              nodeA: { x: nodeA[0], y: nodeA[1] },
              nodeB: { x: nodeB[0], y: nodeB[1] },
              edgeKind,
              stroke,
              strokeWidth
            };
            break;
          }
          case 'text': {
            const text = g.get_text(state.selection.id);
            if (!text) return;
            payload.element = {
              kind: 'text',
              content: text.content,
              position: text.position,
              rotation: text.rotation || 0,
              style: text.style,
              align: text.align,
              textType: text.text_type
            };
            break;
          }
          default:
            return;
        }

        try {
          await navigator.clipboard.writeText(JSON.stringify(payload));
        } catch (err) {
          console.warn('Copy failed:', err);
        }
      }

      async function pasteFromClipboard() {
        let text;
        try {
          text = await navigator.clipboard.readText();
        } catch (err) {
          console.warn('Paste failed - clipboard access denied:', err);
          return;
        }

        let payload;
        try {
          payload = JSON.parse(text);
        } catch {
          console.warn('Paste failed - invalid JSON');
          return;
        }

        // Validate clipboard format
        if (!payload || payload.type !== 'contour-clipboard' || !payload.element) {
          return; // Silently ignore non-contour clipboard data
        }

        // Save state for undo
        const beforeJson = g.to_json();

        const elem = payload.element;
        let newSelection = null;

        switch (elem.kind) {
          case 'node': {
            const newX = elem.x + PASTE_OFFSET;
            const newY = elem.y + PASTE_OFFSET;
            const newId = g.add_node(newX, newY);
            newSelection = { kind: 'node', id: newId };
            break;
          }
          case 'edge': {
            // Create both nodes with offset
            const newAId = g.add_node(elem.nodeA.x + PASTE_OFFSET, elem.nodeA.y + PASTE_OFFSET);
            const newBId = g.add_node(elem.nodeB.x + PASTE_OFFSET, elem.nodeB.y + PASTE_OFFSET);

            // Create the edge
            const newEdgeId = g.add_edge(newAId, newBId);
            if (newEdgeId == null) break;

            // Set edge kind if cubic
            if (elem.edgeKind && typeof elem.edgeKind === 'object' && elem.edgeKind.cubic) {
              const c = elem.edgeKind.cubic;
              const newAPos = g.get_node(newAId);
              const newBPos = g.get_node(newBId);
              if (newAPos && newBPos) {
                g.set_edge_cubic(
                  newEdgeId,
                  newAPos[0] + c.ha.x, newAPos[1] + c.ha.y,
                  newBPos[0] + c.hb.x, newBPos[1] + c.hb.y
                );
                if (c.mode != null && c.mode !== 0 && g.set_handle_mode) {
                  g.set_handle_mode(newEdgeId, c.mode);
                }
              }
            } else if (elem.edgeKind && typeof elem.edgeKind === 'object' && elem.edgeKind.polyline && g.set_edge_polyline) {
              const pts = elem.edgeKind.polyline.points;
              const flat = new Float32Array(pts.length * 2);
              for (let i = 0; i < pts.length; i++) {
                flat[i * 2] = pts[i].x + PASTE_OFFSET;
                flat[i * 2 + 1] = pts[i].y + PASTE_OFFSET;
              }
              g.set_edge_polyline(newEdgeId, flat);
            }

            // Set stroke style
            if (elem.stroke && elem.stroke.length === 4) {
              g.set_edge_style(newEdgeId, elem.stroke[0], elem.stroke[1],
                               elem.stroke[2], elem.stroke[3], elem.strokeWidth || 2);
            }

            newSelection = { kind: 'edge', id: newEdgeId };
            break;
          }
          case 'text': {
            const newX = (elem.position?.x || 0) + PASTE_OFFSET;
            const newY = (elem.position?.y || 0) + PASTE_OFFSET;
            const newId = g.add_text(elem.content || '', newX, newY);

            // Restore text properties
            if (elem.rotation && g.set_text_rotation) g.set_text_rotation(newId, elem.rotation);
            if (elem.align != null && g.set_text_align) g.set_text_align(newId, elem.align);
            if (elem.style) {
              if (elem.style.font_family && elem.style.font_size && g.set_text_font) {
                g.set_text_font(newId, elem.style.font_family, elem.style.font_size);
              }
              if (elem.style.font_weight && g.set_text_font_weight) g.set_text_font_weight(newId, elem.style.font_weight);
              if (elem.style.font_style != null && g.set_text_font_style) g.set_text_font_style(newId, elem.style.font_style);
              if (elem.style.fill_color && g.set_text_fill_color) {
                const c = elem.style.fill_color;
                g.set_text_fill_color(newId, c.r, c.g, c.b, c.a);
              }
              if (elem.style.stroke_color && g.set_text_stroke_color) {
                const c = elem.style.stroke_color;
                g.set_text_stroke_color(newId, c.r, c.g, c.b, c.a);
              }
              if (elem.style.stroke_width && g.set_text_stroke_width) g.set_text_stroke_width(newId, elem.style.stroke_width);
              if (elem.style.letter_spacing && g.set_text_letter_spacing) g.set_text_letter_spacing(newId, elem.style.letter_spacing);
              if (elem.style.line_height && g.set_text_line_height) g.set_text_line_height(newId, elem.style.line_height);
            }

            // Handle text box type
            if (elem.textType && typeof elem.textType === 'object' && elem.textType.type === 'box' && g.convert_text_to_box) {
              g.convert_text_to_box(newId, elem.textType.width, elem.textType.height);
              if (elem.textType.vertical_align != null && g.set_text_box_vertical_align) {
                g.set_text_box_vertical_align(newId, elem.textType.vertical_align);
              }
              if (elem.textType.overflow != null && g.set_text_box_overflow) {
                g.set_text_box_overflow(newId, elem.textType.overflow);
              }
            }

            newSelection = { kind: 'text', id: newId };
            break;
          }
        }

        if (newSelection) {
          // Add to undo history
          state.history.push({
            type: 'paste',
            before: beforeJson,
            after: g.to_json(),
            selection: newSelection
          });
          state.redo.length = 0;

          // Select the pasted element
          state.selection = newSelection;
        }

        scheduleRegions();
        render();
      }

      async function cutSelection() {
        if (!state.selection) return;
        await copySelection();

        // Save state for undo before deleting
        const beforeJson = g.to_json();

        // Delete based on selection type
        switch (state.selection.kind) {
          case 'node':
            g.remove_node(state.selection.id);
            break;
          case 'edge':
            g.remove_edge(state.selection.id);
            break;
          case 'text':
            g.remove_text(state.selection.id);
            break;
        }

        state.history.push({
          type: 'cut',
          before: beforeJson,
          after: g.to_json(),
          selection: null
        });
        state.redo.length = 0;

        state.selection = null;
        scheduleRegions();
        render();
      }

      window.addEventListener('keydown', (evt) => {
        const mod = evt.ctrlKey || evt.metaKey;
        if (mod && evt.key.toLowerCase() === 'c' && !evt.shiftKey) {
          // Copy (Ctrl/Cmd+C)
          evt.preventDefault();
          copySelection();
        } else if (mod && evt.key.toLowerCase() === 'v') {
          // Paste (Ctrl/Cmd+V)
          evt.preventDefault();
          pasteFromClipboard();
        } else if (mod && evt.key.toLowerCase() === 'x') {
          // Cut (Ctrl/Cmd+X)
          evt.preventDefault();
          cutSelection();
        } else if (mod && evt.key.toLowerCase() === 'z') {
          evt.preventDefault();
          if (evt.shiftKey) {
            // redo
            const op = state.redo.pop();
            if (op) {
              if (op.type === 'move_node') {
                g.move_node(op.id, op.after[0], op.after[1]);
              } else if (op.type === 'paste' || op.type === 'cut') {
                g.from_json(op.after);
                state.selection = op.selection;
              }
              state.history.push(op);
              scheduleRegions();
              render();
            }
          } else {
            // undo
            const op = state.history.pop();
            if (op) {
              if (op.type === 'move_node') {
                g.move_node(op.id, op.before[0], op.before[1]);
              } else if (op.type === 'paste' || op.type === 'cut') {
                g.from_json(op.before);
                state.selection = null;
              }
              state.redo.push(op);
              scheduleRegions();
              render();
            }
          }
        } else if (evt.key.toLowerCase() === 's') {
          state.snap = !state.snap; updateSnapLabel(); render();
        } else if (evt.key.toLowerCase() === 'f') {
          state.bucket = !state.bucket; if (state.bucket) { state.pen = false; state.bend = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'b') {
          state.bend = !state.bend; if (state.bend) { state.pen = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'p') {
          state.pen = !state.pen; if (state.pen) { state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } else { state.penPath = null; state.penPreview = null; }
          updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 't') {
          state.textMode = !state.textMode; if (state.textMode) { state.pen = false; state.bend = false; state.bucket = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; state.penPath = null; state.penPreview = null; }
          updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'u') {
          state.rectMode = !state.rectMode; if (state.rectMode) { state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null; }
          updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'o') {
          state.ellipseMode = !state.ellipseMode; if (state.ellipseMode) { state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.polygonMode = false; state.starMode = false; state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null; }
          updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'g') {
          state.polygonMode = !state.polygonMode; if (state.polygonMode) { state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.starMode = false; state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null; }
          updateModeLabel(); render();
        } else if (evt.key === '*' || evt.key === '8' && evt.shiftKey) {
          state.starMode = !state.starMode; if (state.starMode) { state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null; }
          updateModeLabel(); render();
        } else if (evt.key === 'Enter') {
          if (state.pen && state.penPath) { state.penPath = null; state.penPreview = null; render(); }
        } else if (evt.key === 'Escape') {
          if (state.pen && state.penPath) { state.penPath = null; state.penPreview = null; }
          // Clear multi-selection and transform handles
          state.multiSelection = [];
          state.selection = null;
          state.transformHandles = null;
          render();
        } else if (mod && evt.key.toLowerCase() === 'a') {
          // Select All (Ctrl/Cmd+A)
          evt.preventDefault();
          state.multiSelection = [];
          const ed = g.get_edge_data();
          if (ed && ed.ids) {
            for (let i = 0; i < ed.ids.length; i++) {
              state.multiSelection.push({ kind: 'edge', id: ed.ids[i] });
            }
          }
          state.selection = state.multiSelection[0] || null;
          updateTransformHandles();
          render();
        } else if (evt.key.toLowerCase() === 'v') {
          // Selection/transform mode - disable all other modes
          state.pen = false;
          state.bucket = false;
          state.bend = false;
          state.textMode = false;
          state.rectMode = false;
          state.ellipseMode = false;
          state.polygonMode = false;
          state.starMode = false;
          state.penPath = null;
          state.penPreview = null;
          state.primitiveStart = null;
          state.primitiveCurrent = null;
          updateModeLabel();
          render();
        } else if (evt.key.toLowerCase() === 'r') {
          const refBtn = document.getElementById('refBtn');
          state.showRef = !state.showRef; if (refBtn) refBtn.classList.toggle('active', state.showRef); render();
        } else if (evt.key.toLowerCase() === 'c') {
          // Convert selected edge to cubic with default handles
          if (state.selection && state.selection.kind === 'edge') {
            const id = state.selection.id;
            const ed = g.get_edge_data();
            const idx = Array.from(ed.ids).indexOf(id);
            if (idx >= 0) {
              const aId = ed.endpoints[idx*2+0];
              const bId = ed.endpoints[idx*2+1];
              const a = g.get_node(aId); const b = g.get_node(bId);
              const dx = b[0] - a[0]; const dy = b[1] - a[1];
              const len = Math.hypot(dx, dy) || 1;
              const k = 0.3 * len;
              const p1x = a[0] + (dx/len) * k;
              const p1y = a[1] + (dy/len) * k;
              const p2x = b[0] - (dx/len) * k;
              const p2y = b[1] - (dy/len) * k;
              g.set_edge_cubic(id, p1x, p1y, p2x, p2y);
              render();
            }
          }
        } else if (evt.key.toLowerCase() === 'm') {
          // Cycle handle mode for selected cubic edge
          if (state.selection && state.selection.kind === 'edge') {
            const id = state.selection.id;
            const e = g.get_edge_data();
            const idx = Array.from(e.ids).indexOf(id);
            if (idx >= 0 && e.kinds[idx] === 1) {
              state.mode = (state.mode || 0) + 1; if (state.mode > 2) state.mode = 0;
              g.set_handle_mode(id, state.mode);
              render();
            }
          }
        }
      });

      // Double-click: finish pen path (optionally close if near start)
      canvas.addEventListener('dblclick', (evt) => {
        if (state.pen && state.penPath) {
          const [x, y] = canvasPoint(evt);
          const [sx, sy] = snapPoint(x, y, null);
          const start = g.get_node(state.penPath.startId);
          const last = g.get_node(state.penPath.lastId);
          if (start && last) {
            const dx = sx - start[0]; const dy = sy - start[1];
            const close = (dx*dx + dy*dy) <= 12*12;
            if (close && state.penPath.lastId !== state.penPath.startId) {
              g.add_edge(state.penPath.lastId, state.penPath.startId);
              scheduleRegions();
            }
          }
          state.penPath = null; state.penPreview = null; render();
          return;
        }
        // Legacy: add node on double click when not in pen mode
        const [x, y] = canvasPoint(evt);
        const [sx, sy] = snapPoint(x, y, null);
        g.add_node(sx, sy);
        render();
      });

      function pointInPoly(x, y, pts) {
        // pts is [x0,y0,x1,y1,...]
        if (!pts || typeof pts.length !== 'number' || pts.length < 6) return false;
        // Treat near-boundary as inside to avoid flicker
        if (pointNearPolyEdge(x, y, pts, 0.75)) return true;
        let inside = false;
        for (let i = 0, j = pts.length - 2; i < pts.length; j = i, i += 2) {
          const xi = pts[i], yi = pts[i+1];
          const xj = pts[j], yj = pts[j+1];
          const denom = (yj - yi) || 1e-9;
          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / denom + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function pointNearPolyEdge(x, y, pts, eps) {
        const eps2 = eps * eps;
        for (let i = 0; i < pts.length; i += 2) {
          const x1 = pts[i], y1 = pts[i+1];
          const x2 = pts[(i+2)%pts.length], y2 = pts[(i+3)%pts.length];
          const d2 = dist2PointToSeg(x, y, x1, y1, x2, y2);
          if (d2 <= eps2) return true;
        }
        return false;
      }

      function dist2PointToSeg(px, py, x1, y1, x2, y2) {
        const vx = x2 - x1, vy = y2 - y1;
        const wx = px - x1, wy = py - y1;
        const vv = vx*vx + vy*vy;
        let t = vv > 0 ? (wx*vx + wy*vy) / vv : 0;
        if (t < 0) t = 0; else if (t > 1) t = 1;
        const sx = x1 + t*vx, sy = y1 + t*vy;
        const dx = px - sx, dy = py - sy;
        return dx*dx + dy*dy;
      }

      // Buttons: Save/Load/Clear
      document.getElementById('saveBtn').addEventListener('click', () => {
        try {
          const obj = g.to_json();
          localStorage.setItem('contour_doc', JSON.stringify(obj));
        } catch (e) { console.warn('Save failed', e); }
      });
      document.getElementById('loadBtn').addEventListener('click', () => {
        try {
          const saved = localStorage.getItem('contour_doc') || localStorage.getItem('vecnet_doc');
          if (saved) { g.from_json(JSON.parse(saved)); scheduleRegions(); render(); }
        } catch (e) { console.warn('Load failed', e); }
      });
      document.getElementById('clearBtn').addEventListener('click', () => {
        g.clear();
        scheduleRegions(); render();
      });

      // Import SVG (file input + button)
      function importSvgText(text) {
        try {
          const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
          const paths = Array.from(doc.querySelectorAll('path'));
          let added = 0;
          const imported = [];
          const newSvgStrokes = [];
          const newSvgFills = [];
          // Hidden SVG probe for robust isPointInFill tests
          let probe = null;
          try {
            const root = doc.querySelector('svg');
            const viewBox = root ? (root.getAttribute('viewBox') || '0 0 2048 2048') : '0 0 2048 2048';
            probe = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            probe.setAttribute('viewBox', viewBox);
            probe.setAttribute('width', '0'); probe.setAttribute('height', '0');
            probe.style.position = 'absolute'; probe.style.left = '-99999px'; probe.style.top = '-99999px';
            document.body.appendChild(probe);
          } catch { probe = null; }
          for (const p of paths) {
            const d = p.getAttribute('d');
            if (!d || !d.trim()) continue;
            const { color } = resolveFillAndOpacity(p);
            const rule = resolveFillRule(p);
            const transform = p.getAttribute('transform') || null;
            const { strokeColor, strokeWidth } = resolveStroke(p);
            const before = new Set(Array.from((g.get_edge_data().ids) || []));
            try {
              if (strokeColor && strokeWidth != null && typeof g.add_svg_path_with_style === 'function') {
                const [sr,sg,sb,sa] = strokeColor;
                added += g.add_svg_path_with_style(d, sr|0, sg|0, sb|0, sa|0, Math.max(0.5, strokeWidth));
              } else {
                added += g.add_svg_path(d);
              }
              // Gather new edge ids and store style mapping (JS fallback always)
              const after = Array.from((g.get_edge_data().ids) || []);
              const newIds = after.filter(id => !before.has(id));
              if (strokeColor && strokeWidth != null) {
                const [rr,gg,bb,aa] = strokeColor;
                for (const eid of newIds) {
                  if (typeof g.set_edge_style === 'function') {
                    try { g.set_edge_style(eid, rr|0, gg|0, bb|0, aa|0, Math.max(0.5, strokeWidth)); } catch {}
                  }
                  state.edgeStyle[eid] = { color: [rr|0, gg|0, bb|0, aa|0], width: Math.max(0.5, strokeWidth) };
                }
                // Also record for reference overlay rendering
                newSvgStrokes.push({ d, color: [rr|0, gg|0, bb|0, aa|0], width: Math.max(0.5, strokeWidth), cap: (p.getAttribute('stroke-linecap')||'round'), join: (p.getAttribute('stroke-linejoin')||'round') });
              }
              // Create a probe path element for SVGGeometryElement.isPointInFill if available
              let el = null;
              try {
                if (probe) {
                  el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                  el.setAttribute('d', d);
                  if (transform) el.setAttribute('transform', transform);
                  el.setAttribute('fill', (color && Array.isArray(color)) ? `rgba(${color[0]},${color[1]},${color[2]},1)` : '#000');
                  el.setAttribute('fill-rule', rule || 'nonzero');
                  probe.appendChild(el);
                }
              } catch { el = null; }
              imported.push({ d, color, rule, transform, el });
              if (color) newSvgFills.push({ d, color, rule, transform });
            } catch (e) { console.warn('add_svg_path failed', e); }
          }
          // Map fills (if any) to regions
          const updateFills = () => {
            const regionsVal = g.get_regions();
            let regions = [];
            try { regions = JSON.parse(JSON.stringify(regionsVal)); } catch {}
            // Normalize context transform to identity for hit-testing
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            // Detect if isPointInPath(Path2D, ...) works in this browser; Safari may be flaky
            let pathHitWorks = false;
            try {
              const testP = new Path2D('M -1 -1 L 1 -1 L 1 1 L -1 1 z');
              pathHitWorks = !!ctx.isPointInPath(testP, 0, 0, 'nonzero') || !!ctx.isPointInPath(testP, 0, 0);
            } catch { pathHitWorks = false; }
            // Tiny raster fallback for hit-testing when API is unsupported
            const raster = (() => {
              const S = 9; const K = 4; // 9x9 pixels, 4x supersample for stability
              const c = document.createElement('canvas'); c.width = S; c.height = S;
              return { S, K, c, ctx: c.getContext('2d') };
            })();
            function rasterHit(path2d, px, py, rule) {
              const c2 = raster.ctx; if (!c2) return false;
              const S = raster.S, K = raster.K;
              // Clear and set transform so that (px,py) lands at the center pixel
              c2.setTransform(1,0,0,1,0,0); c2.clearRect(0,0,S,S);
              const cx = (S-1)/2, cy = (S-1)/2;
              c2.setTransform(K, 0, 0, K, -px*K + cx, -py*K + cy);
              c2.fillStyle = '#000';
              try {
                if (typeof c2.addPath === 'function') {
                  c2.beginPath(); c2.addPath(path2d);
                  if (typeof c2.fill === 'function' && c2.fill.length >= 1) c2.fill(rule || 'nonzero'); else c2.fill();
                } else if (typeof c2.fill === 'function') {
                  if (c2.fill.length >= 2) c2.fill(path2d, rule || 'nonzero'); else c2.fill(path2d);
                } else { return false; }
              } catch { return false; }
              const img = c2.getImageData(0,0,S,S).data;
              for (let i=3; i<img.length; i+=4) { if (img[i] > 0) return true; }
              return false;
            }
            let coloredAny = false;
            const importedWithColor = imported.filter(imp => imp && imp.color);
            console.log('Import fill items:', importedWithColor.length);
            for (const imp of importedWithColor) {
              const path2d = new Path2D(imp.d);
              const rule = (imp.rule === 'evenodd') ? 'evenodd' : 'nonzero';
              // Optional: support element transform by mapping the test point into path space
              let inv = null;
              try {
                if (imp.transform && typeof DOMMatrix === 'function') {
                  inv = new DOMMatrix(String(imp.transform)).inverse();
                }
              } catch {}
              for (const r of regions) {
                if (!r || !Array.isArray(r.points) || r.points.length < 2) continue;
                const c = centroidOfPoints(r.points);
                let px = c[0], py = c[1];
                if (inv && typeof DOMPoint === 'function') {
                  const p2 = new DOMPoint(c[0], c[1]).matrixTransform(inv);
                  px = p2.x; py = p2.y;
                }
                let inside = false;
                // 1) Prefer native SVG hit test if available
                if (!inside && imp.el && typeof imp.el.isPointInFill === 'function') {
                  try {
                    const pt = (probe && typeof probe.createSVGPoint === 'function') ? probe.createSVGPoint() : null;
                    if (pt) { pt.x = px; pt.y = py; inside = !!imp.el.isPointInFill(pt); }
                  } catch { inside = false; }
                }
                // 2) Canvas Path2D hit-test
                if (!inside) {
                  try {
                    if (pathHitWorks) {
                      if (typeof ctx.isPointInPath === 'function' && ctx.isPointInPath.length >= 4) inside = !!ctx.isPointInPath(path2d, px, py, rule);
                      else inside = !!ctx.isPointInPath(path2d, px, py);
                    }
                  } catch { /* ignore */ }
                }
                // 3) Raster fallback
                if (!inside) inside = rasterHit(path2d, px, py, rule);
                if (inside) {
                  const [rr,gg,bb,aa] = imp.color;
                  g.set_region_fill(r.key >>> 0, true);
                  g.set_region_color(r.key >>> 0, rr, gg, bb, aa);
                  coloredAny = true;
                }
              }
            }
            ctx.restore();
            // Clean up probe DOM
            try { if (probe && probe.parentNode) probe.parentNode.removeChild(probe); } catch {}
            console.log('Applied fill colors?', coloredAny);
            // If no fills assigned at all, turn fills off
            let afterColor = g.get_regions();
            let arr = [];
            try { arr = JSON.parse(JSON.stringify(afterColor)); } catch { arr = []; }
            // Only disable fills when there were no imported fill colors at all; otherwise keep default fallback fill
            if (importedWithColor.length === 0 && !arr.some(r => r && r.color && r.color.length === 4)) {
              for (const r of arr) { g.set_region_fill(r.key >>> 0, false); }
              afterColor = g.get_regions();
            }
            try { state.regions = JSON.parse(JSON.stringify(afterColor)); } catch { state.regions = []; }
            try {
              const stats = { total: state.regions.length, colored: 0, filled: 0 };
              for (const r of state.regions) {
                if (!r) continue;
                if (r.filled) stats.filled++;
                if (r.color && r.color.length === 4) stats.colored++;
              }
              console.log('Region stats:', stats);
            } catch {}
            state.regionsVersion = g.geom_version();
            // Enable reference overlay and store strokes + fills
            state.svgStrokes = newSvgStrokes;
            state.svgFills = newSvgFills;
            state.showRef = state.svgStrokes.length > 0;
            fitToView();
            render();
          };
          if (added > 0) requestAnimationFrame(updateFills); else updateFills();
          console.log(`Imported ${paths.length} <path> tags; edges added: ${added}`);
          console.log('Parsed strokes:', newSvgStrokes.length, newSvgStrokes.slice(0,3));
        } catch (e) { console.warn('SVG parse/import failed', e); }
      }

      // Build objects panel: one entry per edge with a small preview
      function rebuildObjectList() {
        const list = document.getElementById('objList'); if (!list) return;
        list.innerHTML = '';
        const e = g.get_edge_data();
        const ids = e.ids || [];
        const ep = e.endpoints || [];
        const kinds = e.kinds || [];
        const rgba = e.stroke_rgba || [];
        const widths = e.stroke_widths || [];
        for (let i = 0; i < ids.length; i++) {
          const edgeId = ids[i];
          const aId = ep[i*2+0];
          const bId = ep[i*2+1];
          const a = g.get_node(aId); const b = g.get_node(bId);
          if (!a || !b) continue;
          const row = document.createElement('div');
          row.style.cssText = 'display:flex; gap:8px; align-items:center; padding:6px; border:1px solid #eee; border-radius:6px; background:#fff; cursor:pointer;';
          const canvas = document.createElement('canvas');
          canvas.width = 120; canvas.height = 60;
          canvas.style.cssText = 'width:120px; height:60px; background:#fff; border:1px solid #eee; border-radius:4px;';
          const label = document.createElement('div');
          label.textContent = `Path ${edgeId}`;
          label.style.cssText = 'font-size:12px; color:#333;';
          row.appendChild(canvas); row.appendChild(label);
          row.addEventListener('click', () => { state.selection = { kind:'edge', id: edgeId }; render(); });
          list.appendChild(row);

          // Draw preview
          try {
            const ctx2 = canvas.getContext('2d');
            ctx2.clearRect(0,0,canvas.width,canvas.height);
            // Determine color/width
            let col = 'rgba(31,111,235,1)';
            let w = 2;
            let cap = 'round';
            let join = 'round';
            let dash = [];
            if (rgba && rgba.length >= (i*4+4) && widths && widths.length > i) {
              const r = rgba[i*4+0]||0, g2=rgba[i*4+1]||0, b2=rgba[i*4+2]||0, a2=rgba[i*4+3]||255;
              if (a2>0) col = `rgba(${r},${g2},${b2},${Math.max(0,Math.min(1,a2/255))})`;
              if (widths[i]>0) w = widths[i];
            } else if (state.edgeStyle && state.edgeStyle[edgeId]) {
              const st = state.edgeStyle[edgeId]; const [r,g3,b3,a3] = st.color||[31,111,235,255];
              col = `rgba(${r},${g3},${b3},${Math.max(0,Math.min(1,(a3||255)/255))})`; w = st.width||2; cap = st.cap||cap; join = st.join||join; dash = Array.isArray(st.dash)?st.dash:dash;
            }
            // Compute bounds using endpoints + handles (convex hull bounds)
            let pts = [a[0],a[1]];
            if (kinds[i] === 1) {
              const h = g.get_handles(edgeId); if (h) { pts.push(h[0],h[1], h[2],h[3]); }
            } else if (kinds[i] === 2) {
              try { const a = g.get_polyline_points(edgeId); const arr = Array.from(a||[]); for (let t=0;t<arr.length;t+=2){ pts.push(arr[t], arr[t+1]); } } catch {}
            }
            pts.push(b[0],b[1]);
            let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
            for (let k=0;k<pts.length;k+=2){ const x=pts[k], y=pts[k+1]; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) continue;
            const pad = 6; const boxW = Math.max(1,maxX-minX), boxH=Math.max(1,maxY-minY);
            const sx = (canvas.width-2*pad)/boxW, sy=(canvas.height-2*pad)/boxH; const s=Math.min(sx,sy);
            const ox = pad - minX*s; const oy = pad - minY*s;
            ctx2.save(); ctx2.translate(ox,oy); ctx2.scale(s,s);
            ctx2.beginPath(); ctx2.moveTo(a[0],a[1]);
            if (kinds[i] === 1) {
              const h = g.get_handles(edgeId); if (h) ctx2.bezierCurveTo(h[0],h[1],h[2],h[3], b[0],b[1]);
              else ctx2.lineTo(b[0],b[1]);
            } else if (kinds[i] === 2) {
              try { const a = g.get_polyline_points(edgeId); const arr = Array.from(a||[]); for (let t=0;t<arr.length;t+=2){ ctx2.lineTo(arr[t], arr[t+1]); } ctx2.lineTo(b[0],b[1]); } catch { ctx2.lineTo(b[0],b[1]); }
            } else {
              ctx2.lineTo(b[0],b[1]);
            }
            ctx2.strokeStyle = col; ctx2.lineWidth = Math.max(1, w * s);
            ctx2.lineCap=cap; ctx2.lineJoin=join; ctx2.setLineDash(Array.isArray(dash)?dash.map(x=>x*s):[]); ctx2.stroke(); ctx2.setLineDash([]); ctx2.restore();
          } catch (e) { /* ignore */ }
        }
      }
      // Resolve fill color and opacity with basic inheritance (path -> ancestors),
      // defaulting to black if nothing specified (SVG default fill).
      function resolveFillAndOpacity(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { fill: m('fill'), fillOpacity: m('fill-opacity'), opacity: m('opacity') };
        };
        let cur = el;
        let fill = null;
        let fo = null;
        let op = null;
        while (cur) {
          const fAttr = cur.getAttribute && cur.getAttribute('fill');
          const foAttr = cur.getAttribute && cur.getAttribute('fill-opacity');
          const opAttr = cur.getAttribute && cur.getAttribute('opacity');
          const st = readStyle(cur);
          if (fill == null && fAttr != null) fill = fAttr;
          if (fill == null && st.fill != null) fill = st.fill;
          if (fo == null && foAttr != null) fo = foAttr;
          if (fo == null && st.fillOpacity != null) fo = st.fillOpacity;
          if (op == null && opAttr != null) op = opAttr;
          if (op == null && st.opacity != null) op = st.opacity;
          cur = cur.parentNode;
        }
        // Default SVG fill is black if not 'none'
        const opacity = clamp01(parseFloat(fo ?? op ?? '1'));
        // SVG default is black when fill unspecified; honor 'none'.
        const color = parseCssColor(fill == null || String(fill).trim() === '' ? 'black' : fill, opacity);
        return { color };
      }
      function resolveFillRule(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { rule: m('fill-rule') };
        };
        let cur = el; let rule = null;
        while (cur) {
          const attr = cur.getAttribute && cur.getAttribute('fill-rule');
          const st = readStyle(cur);
          if (rule == null && attr != null) rule = String(attr).toLowerCase();
          if (rule == null && st.rule != null) rule = String(st.rule).toLowerCase();
          cur = cur.parentNode;
        }
        return (rule === 'evenodd' || rule === 'nonzero') ? rule : 'nonzero';
      }
      function clamp01(v) { if (!isFinite(v)) return 1; if (v < 0) return 0; if (v > 1) return 1; return v; }
      function parseCssColor(value, opacity=1) {
        if (!value || value === 'none') return null;
        const v = String(value).trim();
        // Tolerant rgb/rgba parser that clamps out-of-range channels
        const m = v.match(/^rgba?\(([^)]+)\)$/i);
        if (m) {
          const parts = m[1].split(',').map(s=>s.trim());
          const to255 = (x) => {
            const n = parseFloat(x);
            if (!isFinite(n)) return 0;
            return Math.max(0, Math.min(255, Math.round(n)));
          };
          const r = to255(parts[0]);
          const g = to255(parts[1]);
          const b = to255(parts[2]);
          const aPart = parts[3] != null ? clamp01(parseFloat(parts[3])) : 1;
          const a = Math.round(clamp01(aPart * opacity) * 255);
          return [r,g,b,a];
        }
        // Hex codes
        if (v[0] === '#') {
          const hex = v.slice(1);
          const norm = hex.length === 3 ? hex.split('').map(c=>c+c).join('') : hex;
          if (/^[0-9a-fA-F]{6}$/.test(norm)) {
            const n = parseInt(norm, 16);
            const r = (n >> 16) & 255, g = (n >> 8) & 255, b = n & 255;
            const a = Math.round(clamp01(opacity) * 255);
            return [r,g,b,a];
          }
        }
        // Named colors: use canvas fallback
        try {
          const c = document.createElement('canvas');
          const cx = c.getContext('2d');
          cx.fillStyle = v;
          const norm = cx.fillStyle;
          const m2 = norm.match(/rgba?\(([^)]+)\)/i);
          if (!m2) return null;
          const parts = m2[1].split(',').map(s=>s.trim());
          const r = parseInt(parts[0],10), g = parseInt(parts[1],10), b = parseInt(parts[2],10);
          const aPart = parts[3] != null ? clamp01(parseFloat(parts[3])) : 1;
          const a = Math.round(clamp01(aPart * opacity) * 255);
          return [r,g,b,a];
        } catch { return null; }
      }
      function centroidOfPoints(pts) {
        // pts: [x0,y0,x1,y1,...]
        if (!pts || typeof pts.length !== 'number' || pts.length < 2) return [0, 0];
        if (pts.length < 6) return [pts[0], pts[1]];
        let area = 0, cx = 0, cy = 0;
        for (let i = 0, j = pts.length-2; i < pts.length; j = i, i += 2) {
          const x0 = pts[j], y0 = pts[j+1], x1 = pts[i], y1 = pts[i+1];
          const cross = x0*y1 - x1*y0; area += cross; cx += (x0 + x1) * cross; cy += (y0 + y1) * cross;
        }
        area *= 0.5; if (Math.abs(area) < 1e-6) return [pts[0], pts[1]];
        return [cx/(6*area), cy/(6*area)];
      }

      function fitToView(padding = 20) {
        // Compute bbox of full geometry: nodes + cubic handles + polyline points.
        // This avoids under-estimating curves that bulge beyond endpoints.
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        // Nodes
        try {
          const data = g.get_node_data();
          const pos = data && data.positions;
          if (pos && pos.length >= 2) {
            for (let i = 0; i < pos.length; i += 2) {
              const x = pos[i], y = pos[i+1];
              if (!isFinite(x) || !isFinite(y)) continue;
              if (x < minX) minX = x; if (y < minY) minY = y;
              if (x > maxX) maxX = x; if (y > maxY) maxY = y;
            }
          }
        } catch {}

        // Edges: include control points and polyline internal points
        try {
          const e = g.get_edge_data();
          const ids = e && e.ids || [];
          const ep = e && e.endpoints || [];
          const kinds = e && e.kinds || [];
          for (let i = 0; i < ids.length; i++) {
            const aId = ep[i*2+0];
            const bId = ep[i*2+1];
            const a = g.get_node(aId);
            const b = g.get_node(bId);
            if (a && b) {
              const pts = [a[0], a[1], b[0], b[1]];
              if (kinds[i] === 1) { // cubic: add handles
                const h = g.get_handles(ids[i]);
                if (h) pts.push(h[0], h[1], h[2], h[3]);
              } else if (kinds[i] === 2) { // polyline: add interior points
                try { const arr = Array.from(g.get_polyline_points(ids[i]) || []); for (let k=0;k+1<arr.length;k+=2) pts.push(arr[k], arr[k+1]); } catch {}
              }
              for (let k = 0; k+1 < pts.length; k += 2) {
                const x = pts[k], y = pts[k+1];
                if (!isFinite(x) || !isFinite(y)) continue;
                if (x < minX) minX = x; if (y < minY) minY = y;
                if (x > maxX) maxX = x; if (y > maxY) maxY = y;
              }
            }
          }
        } catch {}

        if (!(isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY))) return;

        const width = canvas.width / (window.devicePixelRatio || 1);
        const height = canvas.height / (window.devicePixelRatio || 1);
        const boxW = Math.max(1, maxX - minX);
        const boxH = Math.max(1, maxY - minY);
        const sx = (width - 2*padding) / boxW;
        const sy = (height - 2*padding) / boxH;
        const s = Math.max(0.0001, Math.min(sx, sy));
        const tx = padding - minX * s;
        const ty = padding - minY * s;

        // Uniformly transform graph to preserve curve shapes and handle offsets
        g.transform_all(s, tx, ty, true);
        state.transform = { s, tx, ty };
        scheduleRegions();
      }

      function resolveStroke(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { stroke: m('stroke'), strokeOpacity: m('stroke-opacity'), strokeWidth: m('stroke-width'), opacity: m('opacity') };
        };
        let cur = el;
        let stroke = null;
        let so = null;
        let sw = null;
        let op = null;
        while (cur) {
          const sAttr = cur.getAttribute && cur.getAttribute('stroke');
          const soAttr = cur.getAttribute && cur.getAttribute('stroke-opacity');
          const swAttr = cur.getAttribute && cur.getAttribute('stroke-width');
          const opAttr = cur.getAttribute && cur.getAttribute('opacity');
          const st = readStyle(cur);
          if (stroke == null && sAttr != null) stroke = sAttr;
          if (stroke == null && st.stroke != null) stroke = st.stroke;
          if (so == null && soAttr != null) so = soAttr;
          if (so == null && st.strokeOpacity != null) so = st.strokeOpacity;
          if (sw == null && swAttr != null) sw = swAttr;
          if (sw == null && st.strokeWidth != null) sw = st.strokeWidth;
          if (op == null && opAttr != null) op = opAttr;
          if (op == null && st.opacity != null) op = st.opacity;
          cur = cur.parentNode;
        }
        if (!stroke || stroke === 'none') return { strokeColor: null, strokeWidth: null };
        const opacity = clamp01(parseFloat(so ?? op ?? '1'));
        const strokeColor = parseCssColor(stroke, opacity);
        const strokeWidth = parseFloat(sw ?? '2');
        return { strokeColor, strokeWidth: isFinite(strokeWidth) ? strokeWidth : 2 };
      }
      const importInput = document.getElementById('importSvgInput');
      document.getElementById('importBtn').addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', (evt) => {
        const file = evt.target.files && evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => { importSvgText(String(reader.result || '')); importInput.value = ''; };
        reader.onerror = (e) => { console.warn('File read failed', e); importInput.value = ''; };
        reader.readAsText(file);
      });

      // Drag-and-drop SVG onto the canvas
      canvas.addEventListener('dragover', (evt) => { evt.preventDefault(); evt.dataTransfer.dropEffect = 'copy'; });
      canvas.addEventListener('drop', (evt) => {
        evt.preventDefault();
        const dt = evt.dataTransfer;
        if (!dt || !dt.files || dt.files.length === 0) return;
        const file = dt.files[0];
        if (!file.type.includes('svg') && !file.name.toLowerCase().endsWith('.svg')) { console.warn('Not an SVG'); return; }
        const reader = new FileReader();
        reader.onload = () => importSvgText(String(reader.result || ''));
        reader.onerror = (e) => console.warn('Drop read failed', e);
        reader.readAsText(file);
      });

      const penBtn = document.getElementById('penBtn');
      if (penBtn) penBtn.addEventListener('click', () => { state.pen = !state.pen; if (state.pen) { state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } else { state.penPath = null; state.penPreview = null; } updateModeLabel(); render(); });
      const penModeSel = document.getElementById('penMode');
      if (penModeSel) penModeSel.addEventListener('change', (e) => {
        const v = e.target && e.target.value ? String(e.target.value) : 'points';
        state.penMode = (v === 'free') ? 'free' : 'points';
        // Cancel any in-progress drawing for clean switch
        state.penPath = null; state.penPreview = null; state.freeDrawing = false; state.freePoints = null;
        updateModeLabel(); render();
      });
      document.getElementById('bucketBtn').addEventListener('click', () => {
        state.bucket = !state.bucket; if (state.bucket) { state.pen = false; state.bend = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } updateModeLabel(); render();
      });
      document.getElementById('bendBtn').addEventListener('click', () => {
        state.bend = !state.bend; if (state.bend) { state.pen = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false; } updateModeLabel(); render();
      });
      const refBtn = document.getElementById('refBtn');
      if (refBtn) {
        refBtn.addEventListener('click', () => {
          state.showRef = !state.showRef;
          refBtn.classList.toggle('active', state.showRef);
          render();
        });
      }

      // Text tool button
      const textBtn = document.getElementById('textBtn');
      if (textBtn) {
        textBtn.addEventListener('click', () => {
          state.textMode = !state.textMode;
          if (state.textMode) {
            state.pen = false; state.bend = false; state.bucket = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false;
            state.penPath = null; state.penPreview = null;
          }
          updateModeLabel(); render();
        });
      }

      // Rectangle tool button
      const rectBtn = document.getElementById('rectBtn');
      if (rectBtn) {
        rectBtn.addEventListener('click', () => {
          state.rectMode = !state.rectMode;
          if (state.rectMode) {
            state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.ellipseMode = false; state.polygonMode = false; state.starMode = false;
            state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null;
          }
          updateModeLabel(); render();
        });
      }

      // Ellipse tool button
      const ellipseBtn = document.getElementById('ellipseBtn');
      if (ellipseBtn) {
        ellipseBtn.addEventListener('click', () => {
          state.ellipseMode = !state.ellipseMode;
          if (state.ellipseMode) {
            state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.polygonMode = false; state.starMode = false;
            state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null;
          }
          updateModeLabel(); render();
        });
      }

      // Polygon tool button
      const polygonBtn = document.getElementById('polygonBtn');
      if (polygonBtn) {
        polygonBtn.addEventListener('click', () => {
          state.polygonMode = !state.polygonMode;
          if (state.polygonMode) {
            state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.starMode = false;
            state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null;
          }
          updateModeLabel(); render();
        });
      }

      // Star tool button
      const starBtn = document.getElementById('starBtn');
      if (starBtn) {
        starBtn.addEventListener('click', () => {
          state.starMode = !state.starMode;
          if (state.starMode) {
            state.pen = false; state.bend = false; state.bucket = false; state.textMode = false; state.rectMode = false; state.ellipseMode = false; state.polygonMode = false;
            state.penPath = null; state.penPreview = null; state.primitiveStart = null; state.primitiveCurrent = null;
          }
          updateModeLabel(); render();
        });
      }

      // Primitive settings panel handlers
      const polygonSidesInput = document.getElementById('polygonSidesInput');
      const polygonSidesVal = document.getElementById('polygonSidesVal');
      const starPointsInput = document.getElementById('starPointsInput');
      const starPointsVal = document.getElementById('starPointsVal');
      const starInnerInput = document.getElementById('starInnerInput');
      const starInnerVal = document.getElementById('starInnerVal');

      if (polygonSidesInput) {
        polygonSidesInput.addEventListener('input', () => {
          state.polygonSides = parseInt(polygonSidesInput.value) || 6;
          if (polygonSidesVal) polygonSidesVal.textContent = state.polygonSides;
          updateModeLabel();
        });
      }
      if (starPointsInput) {
        starPointsInput.addEventListener('input', () => {
          state.starPoints = parseInt(starPointsInput.value) || 5;
          if (starPointsVal) starPointsVal.textContent = state.starPoints;
          updateModeLabel();
        });
      }
      if (starInnerInput) {
        starInnerInput.addEventListener('input', () => {
          state.starInnerRatio = (parseInt(starInnerInput.value) || 50) / 100;
          if (starInnerVal) starInnerVal.textContent = (state.starInnerRatio * 100).toFixed(0) + '%';
        });
      }

      // Text properties panel handlers
      const textContentInput = document.getElementById('textContent');
      const textSizeInput = document.getElementById('textSize');
      const textSizeVal = document.getElementById('textSizeVal');
      const textAlignSelect = document.getElementById('textAlign');
      const textColorInput = document.getElementById('textColor');
      const textToOutlinesBtn = document.getElementById('textToOutlinesBtn');
      const deleteTextBtn = document.getElementById('deleteTextBtn');

      function updateTextFromUI() {
        if (!state.selection || state.selection.kind !== 'text') return;
        const tid = state.selection.id;
        const content = textContentInput.value;
        const size = parseFloat(textSizeInput.value) || 16;
        const align = parseInt(textAlignSelect.value) || 0;
        const colorHex = textColorInput.value || '#000000';
        const [r, gc, b] = hexToRgb(colorHex);

        if (typeof g.set_text_content === 'function') g.set_text_content(tid, content);
        if (typeof g.set_text_font === 'function') g.set_text_font(tid, 'sans-serif', size);
        if (typeof g.set_text_align === 'function') g.set_text_align(tid, align);
        if (typeof g.set_text_fill_color === 'function') g.set_text_fill_color(tid, r, gc, b, 255);
        render();
      }

      if (textContentInput) textContentInput.addEventListener('input', updateTextFromUI);
      if (textSizeInput) {
        textSizeInput.addEventListener('input', () => {
          if (textSizeVal) textSizeVal.textContent = textSizeInput.value + 'px';
          updateTextFromUI();
        });
      }
      if (textAlignSelect) textAlignSelect.addEventListener('change', updateTextFromUI);
      if (textColorInput) textColorInput.addEventListener('input', updateTextFromUI);

      if (deleteTextBtn) {
        deleteTextBtn.addEventListener('click', () => {
          if (state.selection && state.selection.kind === 'text') {
            if (typeof g.remove_text === 'function') g.remove_text(state.selection.id);
            state.selection = null;
            updateModeLabel(); render();
          }
        });
      }

      if (textToOutlinesBtn) {
        textToOutlinesBtn.addEventListener('click', () => {
          if (state.selection && state.selection.kind === 'text') {
            // Text to outlines requires glyph data from JS font library
            // For demo, we'll show a placeholder message
            console.log('Text to outlines: requires font glyph data from opentype.js or similar');
            alert('Text to outlines requires font glyph data.\nIntegrate opentype.js and call g.text_to_outlines(textId, glyphData)');
          }
        });
      }

      // Populate text properties when text is selected
      function refreshTextPropertiesPanel() {
        if (!state.selection || state.selection.kind !== 'text') return;
        const tid = state.selection.id;
        try {
          const tdata = g.get_text(tid);
          if (!tdata) return;
          const style = tdata.style || {};
          if (textContentInput) textContentInput.value = tdata.content || '';
          if (textSizeInput) textSizeInput.value = style.font_size || 16;
          if (textSizeVal) textSizeVal.textContent = (style.font_size || 16) + 'px';
          const alignVal = typeof tdata.align === 'number' ? tdata.align : (tdata.align === 'Center' ? 1 : tdata.align === 'Right' ? 2 : 0);
          if (textAlignSelect) textAlignSelect.value = String(alignVal);
          if (textColorInput && style.fill_color) {
            const fc = style.fill_color;
            textColorInput.value = rgbToHex(fc.r || 0, fc.g || 0, fc.b || 0);
          }
        } catch (e) { console.warn('Text props error:', e); }
      }

      // Shape inference button
      const inferShapesBtn = document.getElementById('inferShapesBtn');
      if (inferShapesBtn) {
        inferShapesBtn.addEventListener('click', () => {
          try {
            // First, infer any NEW shapes from unassigned edges
            if (typeof g.infer_shapes === 'function') {
              const newShapes = g.infer_shapes();
              console.log('Newly inferred shapes:', newShapes ? Array.from(newShapes) : []);
            }
            // Then get ALL existing shape IDs (including previously created ones)
            // infer_shapes only returns NEW shapes, so we need get_shape_ids for the full list
            if (typeof g.get_shape_ids === 'function') {
              const allShapeIds = g.get_shape_ids();
              const shapeIds = allShapeIds ? Array.from(allShapeIds) : [];
              state.shapes = shapeIds.map(id => ({ id }));
              state.selectedShapes = [];
              updateBooleanButtons();
              updateShapeList();
              updateModeLabel();
              render();
              console.log('All shapes:', shapeIds.length, shapeIds);
            }
          } catch (e) { console.warn('Infer shapes error:', e); }
        });
      }

      function updateShapeList() {
        const shapeList = document.getElementById('shapeList');
        if (!shapeList) return;
        if (state.shapes.length === 0) {
          shapeList.innerHTML = '<div class="hint">No shapes detected. Draw closed paths and click Shapes.</div>';
          return;
        }
        shapeList.innerHTML = state.shapes.map((s, i) => {
          const selected = state.selectedShapes.includes(s.id);
          return `<div style="padding:4px 8px; margin:2px 0; border-radius:4px; cursor:pointer; background:${selected ? '#e3f2fd' : '#f5f5f5'}; border:1px solid ${selected ? '#2196f3' : '#ddd'};" data-shape-id="${s.id}">Shape ${s.id}</div>`;
        }).join('');
        // Add click handlers
        shapeList.querySelectorAll('[data-shape-id]').forEach(el => {
          el.addEventListener('click', () => {
            const sid = parseInt(el.dataset.shapeId);
            const idx = state.selectedShapes.indexOf(sid);
            if (idx >= 0) {
              state.selectedShapes.splice(idx, 1);
            } else if (state.selectedShapes.length < 2) {
              state.selectedShapes.push(sid);
            } else {
              // Replace first selection
              state.selectedShapes = [state.selectedShapes[1], sid];
            }
            updateBooleanButtons();
            updateShapeList();
            render();
          });
        });
      }

      function updateBooleanButtons() {
        const enabled = state.selectedShapes.length === 2;
        document.getElementById('unionBtn').disabled = !enabled;
        document.getElementById('intersectBtn').disabled = !enabled;
        document.getElementById('diffBtn').disabled = !enabled;
        document.getElementById('xorBtn').disabled = !enabled;
      }

      // Boolean operation buttons
      function doBooleanOp(opName) {
        if (state.selectedShapes.length !== 2) return;
        const [a, b] = state.selectedShapes;
        try {
          let result = null;
          switch (opName) {
            case 'union': result = g.boolean_union(a, b); break;
            case 'intersect': result = g.boolean_intersect(a, b); break;
            case 'difference': result = g.boolean_difference(a, b); break;
            case 'xor': result = g.boolean_xor(a, b); break;
          }
          console.log(`Boolean ${opName} result:`, result);
          // Re-infer shapes after operation and get ALL shapes
          state.selectedShapes = [];
          if (typeof g.infer_shapes === 'function') {
            g.infer_shapes(); // Create any new shapes from unassigned edges
          }
          if (typeof g.get_shape_ids === 'function') {
            const allShapeIds = g.get_shape_ids();
            const shapeIds = allShapeIds ? Array.from(allShapeIds) : [];
            state.shapes = shapeIds.map(id => ({ id }));
          }
          updateBooleanButtons();
          updateShapeList();
          scheduleRegions();
          render();
        } catch (e) {
          console.error(`Boolean ${opName} error:`, e);
          alert(`Boolean ${opName} failed: ${e.message || e}`);
        }
      }

      document.getElementById('unionBtn').addEventListener('click', () => doBooleanOp('union'));
      document.getElementById('intersectBtn').addEventListener('click', () => doBooleanOp('intersect'));
      document.getElementById('diffBtn').addEventListener('click', () => doBooleanOp('difference'));
      document.getElementById('xorBtn').addEventListener('click', () => doBooleanOp('xor'));

      render();
    </script>
  </body>
  </html>
