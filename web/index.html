<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>contour demo</title>
    <style>
      html, body { height: 100%; margin: 0; }
      body { font-family: system-ui, sans-serif; display: flex; flex-direction: column; }
      header { padding: 12px 16px; border-bottom: 1px solid #ddd; }
      #stage { flex: 1; position: relative; background: #fff; }
      canvas { width: 100%; height: 100%; display: block; background: #fafafa; }
      .hint { color: #666; font-size: 12px; }
    </style>
  </head>
  <body>
    <header>
      <div><strong>contour</strong> â€” MVP 3 (fills + paint bucket)</div>
      <div class="hint">
        Build with <code>wasm-pack build --target web</code>.
        Drag nodes. Connect: Alt+drag from node to node. 
        Snap: toggle with <code>S</code> (grid+nodes). 
        Fill tool: toggle with <code>F</code> (click region to toggle fill).
        Undo: Ctrl/Cmd+Z. Redo: Shift+Ctrl/Cmd+Z.
      </div>
      <div style="margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <div id="toolbar" style="display:flex; gap:6px; align-items:center; border:1px solid #e2e2e2; border-radius:8px; padding:6px; background:#fff;">
          <button id="penBtn" title="Pen tool (P)">Pen</button>
          <select id="penMode" title="Pen mode" style="font-size:12px; padding:4px 6px; border:1px solid #e2e2e2; border-radius:6px; background:#fff;">
            <option value="points">Points</option>
            <option value="free">Free Draw</option>
          </select>
          <button id="bendBtn" title="Toggle bend tool (B)">Bend</button>
          <button id="bucketBtn" title="Toggle paint bucket (F)">Bucket</button>
          <button id="refBtn" title="Toggle reference SVG overlay (R)">Ref</button>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="saveBtn">Save</button>
          <button id="loadBtn">Load</button>
          <button id="clearBtn">Clear</button>
          <button id="importBtn" title="Import an SVG file">Import SVG</button>
          <input id="importSvgInput" type="file" accept=".svg,image/svg+xml" style="display:none" />
        </div>
        <span class="hint" id="snapLabel"></span>
        <span class="hint" id="modeLabel"></span>
      </div>
    </header>
    <div id="main" style="flex:1; display:flex; min-height:0;">
      <div id="stage" style="flex:1; position:relative; background:#fff; min-width:0;">
        <canvas id="canvas"></canvas>
      </div>
      <aside id="sidebar" style="width:280px; border-left:1px solid #ddd; background:#fafbfc; display:flex; flex-direction:column; overflow:hidden;">
        <div style="padding:8px 10px; border-bottom:1px solid #eee; font-weight:600; flex:0 0 auto;">Objects</div>
        <div id="objList" style="padding:8px; display:flex; flex-direction:column; gap:8px; overflow:auto; flex:1 1 auto; min-height:120px;"></div>
        <div style="padding:8px 10px; border-top:1px solid #eee; font-weight:600; flex:0 0 auto;">Properties</div>
        <div id="props" style="padding:10px; display:flex; flex-direction:column; gap:10px; background:#fff; border-top:1px solid #eee; box-shadow:0 -4px 10px rgba(0,0,0,0.04); position:sticky; bottom:0; flex:0 0 auto;">
          <div class="hint">Select a path to edit style.</div>
        </div>
      </aside>
    </div>

    <script type="module">
      import init, { Graph } from "../pkg/contour_wasm.js";
      await init();

      const g = new Graph();
      // If saved doc exists, load it
      let loaded = false;
      try {
        // Prefer new key; fallback to legacy for backward compatibility
        const savedNew = localStorage.getItem('contour_doc');
        const savedOld = !savedNew ? localStorage.getItem('vecnet_doc') : null;
        const saved = savedNew || savedOld;
        if (saved) { loaded = g.from_json(JSON.parse(saved)); }
        // Migrate legacy key to new key after successful load
        if (loaded && savedOld) { try { localStorage.setItem('contour_doc', savedOld); } catch {} }
      } catch (e) { console.warn('Load failed', e); }
      // Start empty by default (no seeded geometry)

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      const state = {
        selection: null, // { kind: 'node'|'edge', id }
        dragging: null,  // { id, start:[x,y], orig:[x,y] }
        connecting: null, // { startId, startPos:[x,y], cur:[x,y] }
        hover: null,     // { kind, id }
        hoverRegion: null, // { key, points }
        history: [],     // undo stack
        redo: [],        // redo stack
        snap: true,
        pen: false,
        penMode: 'points',
        bucket: false,
        regionsVersion: 0,
        regions: [],
        bend: false,
        bending: null, // { edge, t }
        penPath: null, // { startId, lastId }
        penPreview: null, // [x,y]
        freeDrawing: false,
        freePoints: null, // [x0,y0,x1,y1,...]
        edgeStyle: {}, // fallback JS-side style map: id -> { color:[r,g,b,a], width }
        svgStrokes: [], // [{ d, color:[r,g,b,a], width, cap, join }]
        svgFills: [],   // [{ d, color:[r,g,b,a], rule, transform }]
        showRef: false,
        transform: { s: 1, tx: 0, ty: 0 },
      };

      const snapLabel = document.getElementById('snapLabel');
      const modeLabel = document.getElementById('modeLabel');
      function updateSnapLabel() {
        snapLabel.textContent = state.snap ? 'Snap: ON' : 'Snap: OFF';
      }
      function updateModeLabel() {
        let mode = 'Select/Drag';
        if (state.pen) mode = 'Pen' + (state.penMode === 'free' ? ' (Free)' : ''); else if (state.bucket) mode = 'Bucket'; else if (state.bend) mode = 'Bend';
        modeLabel.textContent = 'Mode: ' + mode;
        canvas.style.cursor = state.bucket ? 'cell' : (state.bend ? 'crosshair' : (state.pen ? 'crosshair' : 'default'));
        document.getElementById('bucketBtn').classList.toggle('active', state.bucket);
        const bendBtn = document.getElementById('bendBtn'); if (bendBtn) bendBtn.classList.toggle('active', state.bend);
        const penBtn = document.getElementById('penBtn'); if (penBtn) penBtn.classList.toggle('active', state.pen);
      }
      updateSnapLabel();
      updateModeLabel();

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        render();
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      // Prime regions on load
      (function(){
        const regionsVal = g.get_regions();
        try { state.regions = JSON.parse(JSON.stringify(regionsVal)); }
        catch (e) { console.warn('regions normalize failed', e, regionsVal); state.regions = []; }
        state.regionsVersion = g.geom_version();
        render();
      })();

      function render() {
        // Rebuild object list if geometry changed
        try {
          const gv = g.geom_version();
          if (gv !== state.objectsVersion) { rebuildObjectList(); state.objectsVersion = gv; }
        } catch {}
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Keep properties panel in sync with selection
        refreshPropertiesPanel();

        // SVG fills imported: draw behind everything, aligned with current transform
        if (Array.isArray(state.svgFills) && state.svgFills.length > 0) {
          ctx.save();
          const t = state.transform || { s: 1, tx: 0, ty: 0 };
          ctx.translate(t.tx, t.ty);
          ctx.scale(t.s, t.s);
          for (const f of state.svgFills) {
            try {
              ctx.save();
              if (f.transform && typeof DOMMatrix === 'function') {
                const m = new DOMMatrix(String(f.transform));
                ctx.transform(m.a, m.b, m.c, m.d, m.e, m.f);
              }
              const p = new Path2D(f.d);
              const [rr,gg,bb,aa] = f.color;
              ctx.fillStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              if (typeof ctx.fill === 'function' && ctx.fill.length >= 2) ctx.fill(p, f.rule || 'nonzero'); else ctx.fill(p);
              ctx.restore();
            } catch {}
          }
          ctx.restore();
        }

        // Fills: draw behind edges (engine regions)
        const regions = state.regions;
        if (regions && Array.isArray(regions)) {
          ctx.save();
          for (const r of regions) {
            if (!r.filled) continue;
            const pts = r.points;
            if (!pts || pts.length < 6) continue;
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (let i = 2; i < pts.length; i += 2) ctx.lineTo(pts[i], pts[i+1]);
            ctx.closePath();
            // Use per-region color if present; else fallback
            if (r.color && r.color.length === 4) {
              const [rr, gg, bb, aa] = r.color;
              ctx.fillStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
            } else {
              ctx.fillStyle = 'rgba(56, 139, 253, 0.15)';
            }
            ctx.fill();
          }
          ctx.restore();
        }

        // If we have SVG stroke overlays and Ref mode is ON, draw them and return early
        if (state.showRef && state.svgStrokes && state.svgStrokes.length > 0) {
          ctx.save();
          const t = state.transform || { s: 1, tx: 0, ty: 0 };
          ctx.translate(t.tx, t.ty);
          ctx.scale(t.s, t.s);
          for (const s of state.svgStrokes) {
            try {
              const p = new Path2D(s.d);
              const [rr,gg,bb,aa] = s.color;
              ctx.strokeStyle = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              ctx.lineWidth = s.width;
              ctx.lineCap = s.cap || 'round';
              ctx.lineJoin = s.join || 'round';
              ctx.stroke(p);
            } catch {}
          }
          ctx.restore();
          return; // Skip engine edges/nodes to avoid masking the reference
        }

        // Edges (draw when reference overlay is off)
        const e = g.get_edge_data();
        const eids = e.ids; // Uint32Array
        const ep = e.endpoints; // Uint32Array [a,b,...]
        const kinds = e.kinds; // Uint8Array 0=line,1=cubic,2=polyline
        const rgba = e.stroke_rgba; // Uint8Array (4 per edge) or undefined
        const widths = e.stroke_widths; // Float32Array or undefined
        ctx.lineWidth = 2;
        for (let i = 0; i < eids.length; i++) {
          const a = ep[i*2+0];
          const b = ep[i*2+1];
          const na = g.get_node(a);
          const nb = g.get_node(b);
          if (!na || !nb) continue;
          const edgeId = eids[i];
          const selected = state.selection && state.selection.kind === 'edge' && state.selection.id === edgeId;
          const hovered = state.hover && state.hover.kind === 'edge' && state.hover.id === edgeId;
          // Base stroke style from edge typed arrays (fast, reliable)
          let baseColor = '#1f6feb';
          let baseWidth = 2;
          let cap = 'round';
          let join = 'round';
          let dash = [];
          if (rgba && widths) {
            const r = rgba[i*4+0] || 0;
            const g2 = rgba[i*4+1] || 0;
            const b2 = rgba[i*4+2] || 0;
            const a2 = rgba[i*4+3] || 0;
            const w2 = widths[i] || 0;
            if (a2 > 0 && w2 > 0) {
              baseColor = `rgba(${r}, ${g2}, ${b2}, ${Math.max(0, Math.min(1, a2/255))})`;
              baseWidth = w2;
            }
          }
          // Fallback: JS-side style map or get_edge_style if arrays indicate unset
          if (baseWidth === 2 && baseColor === '#1f6feb') {
            const jsStyle = state.edgeStyle && state.edgeStyle[edgeId];
            if (jsStyle && jsStyle.color && jsStyle.color.length === 4) {
              const [rr,gg,bb,aa] = jsStyle.color;
              baseColor = `rgba(${rr}, ${gg}, ${bb}, ${Math.max(0, Math.min(1, aa/255))})`;
              baseWidth = (typeof jsStyle.width === 'number' && jsStyle.width > 0) ? jsStyle.width : baseWidth;
              cap = jsStyle.cap || cap;
              join = jsStyle.join || join;
              dash = Array.isArray(jsStyle.dash) ? jsStyle.dash : dash;
            } else if (typeof g.get_edge_style === 'function') {
              try {
                const stRaw = g.get_edge_style(edgeId);
                let st = null; try { st = JSON.parse(JSON.stringify(stRaw)); } catch { st = stRaw; }
                if (st && (Array.isArray(st) ? st.length >= 5 : (st[0] !== undefined && st[4] !== undefined))) {
                  const rr = (Array.isArray(st) ? st[0] : st[0])|0;
                  const gg3 = (Array.isArray(st) ? st[1] : st[1])|0;
                  const bb3 = (Array.isArray(st) ? st[2] : st[2])|0;
                  const aa3 = (Array.isArray(st) ? st[3] : st[3])|0;
                  const ww = Array.isArray(st) ? st[4] : st[4];
                  baseColor = `rgba(${rr}, ${gg3}, ${bb3}, ${Math.max(0, Math.min(1, aa3/255))})`;
                  baseWidth = (typeof ww === 'number' && isFinite(ww) && ww > 0) ? ww : 2;
                }
              } catch {}
            }
          }

          ctx.beginPath();
          ctx.moveTo(na[0], na[1]);
          if (kinds[i] === 1) {
            const handles = g.get_handles(edgeId);
            if (handles) {
              ctx.bezierCurveTo(handles[0], handles[1], handles[2], handles[3], nb[0], nb[1]);
            } else {
              ctx.lineTo(nb[0], nb[1]);
            }
          } else if (kinds[i] === 2) {
            try {
              const pts = g.get_polyline_points(edgeId);
              const arr = Array.from(pts || []);
              for (let k = 0; k+1 < arr.length; k += 2) ctx.lineTo(arr[k], arr[k+1]);
              ctx.lineTo(nb[0], nb[1]);
            } catch { ctx.lineTo(nb[0], nb[1]); }
          } else {
            ctx.lineTo(nb[0], nb[1]);
          }
          // Use per-edge cap/join/dash if provided
          ctx.lineCap = cap;
          ctx.lineJoin = join;
          ctx.setLineDash(Array.isArray(dash) ? dash : []);
          ctx.strokeStyle = selected ? '#d73a49' : hovered ? '#2da44e' : baseColor;
          ctx.lineWidth = selected ? Math.max(4, baseWidth * 1.6) : hovered ? Math.max(3, baseWidth * 1.3) : baseWidth;
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Nodes
        const n = g.get_node_data();
        const nids = n.ids; // Uint32Array
        const pos = n.positions; // Float32Array [x,y,...]
        for (let i = 0; i < nids.length; i++) {
          const id = nids[i];
          const x = pos[i*2+0];
          const y = pos[i*2+1];
          const selected = state.selection && state.selection.kind === 'node' && state.selection.id === id;
          const hovered = state.hover && state.hover.kind === 'node' && state.hover.id === id;
          ctx.beginPath();
          ctx.arc(x, y, selected ? 6 : hovered ? 5 : 4, 0, Math.PI * 2);
          ctx.fillStyle = selected ? '#d73a49' : hovered ? '#2da44e' : '#111';
          ctx.fill();
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#fff';
          ctx.stroke();
        }

        // Handles for selected edge
        if (state.selection && state.selection.kind === 'edge') {
          const id = state.selection.id;
          const handles = g.get_handles(id);
          if (handles) {
            const ed = g.get_edge_data();
            const idx = Array.from(ed.ids).indexOf(id);
            if (idx >= 0) {
              const aId = ed.endpoints[idx*2+0];
              const bId = ed.endpoints[idx*2+1];
              const a = g.get_node(aId);
              const b = g.get_node(bId);
              // stems
              ctx.beginPath();
              ctx.moveTo(a[0], a[1]); ctx.lineTo(handles[0], handles[1]);
              ctx.moveTo(b[0], b[1]); ctx.lineTo(handles[2], handles[3]);
              ctx.strokeStyle = '#999';
              ctx.lineWidth = 1;
              ctx.setLineDash([4, 4]);
              ctx.stroke();
              ctx.setLineDash([]);
              // knobs
              for (let k = 0; k < 2; k++) {
                const hx = handles[k*2+0];
                const hy = handles[k*2+1];
                const hovered = state.hover && state.hover.kind === 'handle' && state.hover.edge === id && state.hover.end === k;
                const radius = hovered ? 5 : 4;
                ctx.beginPath();
                ctx.arc(hx, hy, radius, 0, Math.PI * 2);
                ctx.fillStyle = hovered ? '#2da44e' : '#fff';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#d73a49';
                ctx.stroke();
              }
            }
          }
        }

        // Connection preview (rubber band)
        if (state.connecting) {
          const start = g.get_node(state.connecting.startId);
          if (start) {
            const [sx, sy] = start;
            const [cx, cy] = state.connecting.cur;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(cx, cy);
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }

        // Pen tool rubber band (points mode)
        if (state.pen && state.penMode === 'points' && state.penPath && state.penPreview) {
          const last = g.get_node(state.penPath.lastId);
          if (last) {
            const [sx, sy] = [last[0], last[1]];
            const [cx, cy] = state.penPreview;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(cx, cy);
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
        // Pen free-draw preview
        if (state.pen && state.penMode === 'free' && state.freeDrawing && Array.isArray(state.freePoints) && state.freePoints.length >= 4) {
          ctx.beginPath();
          ctx.moveTo(state.freePoints[0], state.freePoints[1]);
          for (let i = 2; i < state.freePoints.length; i += 2) ctx.lineTo(state.freePoints[i], state.freePoints[i+1]);
          ctx.strokeStyle = '#ff9800';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // --- Properties panel (per-edge stroke controls) ---
      function ensurePropertiesPanel() {
        const props = document.getElementById('props'); if (!props) return;
        if (props.dataset.built === '1') return;
        props.dataset.built = '1';
        props.innerHTML = '';
        // Title row updates dynamically
        const title = document.createElement('div');
        title.id = 'propsTitle';
        title.style.cssText = 'font-size:12px; color:#555;';
        props.appendChild(title);

        // Color + Opacity
        const colorRow = document.createElement('div');
        colorRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const colorLabel = document.createElement('div'); colorLabel.textContent = 'Stroke'; colorLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.id = 'strokeColor'; colorInput.style.cssText = 'flex:0 0 auto; width:36px; height:24px; padding:0; border:none; background:none;';
        const opacityInput = document.createElement('input'); opacityInput.type = 'range'; opacityInput.min = '0'; opacityInput.max = '100'; opacityInput.step = '1'; opacityInput.id = 'strokeOpacity'; opacityInput.style.cssText = 'flex:1;';
        const opacityVal = document.createElement('div'); opacityVal.id = 'strokeOpacityVal'; opacityVal.style.cssText = 'width:36px; text-align:right; font-size:12px; color:#555;';
        colorRow.appendChild(colorLabel); colorRow.appendChild(colorInput); colorRow.appendChild(opacityInput); colorRow.appendChild(opacityVal);
        props.appendChild(colorRow);

        // Width
        const widthRow = document.createElement('div'); widthRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const widthLabel = document.createElement('div'); widthLabel.textContent = 'Width'; widthLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const widthInput = document.createElement('input'); widthInput.type = 'range'; widthInput.min = '0.5'; widthInput.max = '20'; widthInput.step = '0.5'; widthInput.id = 'strokeWidth'; widthInput.style.cssText = 'flex:1;';
        const widthVal = document.createElement('div'); widthVal.id = 'strokeWidthVal'; widthVal.style.cssText = 'width:36px; text-align:right; font-size:12px; color:#555;';
        widthRow.appendChild(widthLabel); widthRow.appendChild(widthInput); widthRow.appendChild(widthVal);
        props.appendChild(widthRow);

        // Line Cap
        const capRow = document.createElement('div'); capRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const capLabel = document.createElement('div'); capLabel.textContent = 'Cap'; capLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const capSelect = document.createElement('select'); capSelect.id = 'lineCap'; capSelect.style.cssText = 'flex:1;';
        ['round','butt','square'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; capSelect.appendChild(o); });
        capRow.appendChild(capLabel); capRow.appendChild(capSelect); props.appendChild(capRow);

        // Line Join
        const joinRow = document.createElement('div'); joinRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const joinLabel = document.createElement('div'); joinLabel.textContent = 'Join'; joinLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const joinSelect = document.createElement('select'); joinSelect.id = 'lineJoin'; joinSelect.style.cssText = 'flex:1;';
        ['round','bevel','miter'].forEach(v => { const o=document.createElement('option'); o.value=v; o.textContent=v; joinSelect.appendChild(o); });
        joinRow.appendChild(joinLabel); joinRow.appendChild(joinSelect); props.appendChild(joinRow);

        // Line Dash
        const dashRow = document.createElement('div'); dashRow.style.cssText = 'display:flex; align-items:center; gap:8px;';
        const dashLabel = document.createElement('div'); dashLabel.textContent = 'Dash'; dashLabel.style.cssText = 'width:56px; font-size:12px; color:#333;';
        const dashPreset = document.createElement('select'); dashPreset.id = 'lineDashPreset'; dashPreset.style.cssText = 'flex:0 0 90px;';
        [['','Solid'],['5,5','Dashed'],['2,6','Dotted'],['custom','Custom']].forEach(([val,lab])=>{ const o=document.createElement('option'); o.value=val; o.textContent=lab; dashPreset.appendChild(o); });
        const dashInput = document.createElement('input'); dashInput.type = 'text'; dashInput.placeholder = 'e.g. 6,4'; dashInput.id = 'lineDash'; dashInput.style.cssText = 'flex:1;';
        dashRow.appendChild(dashLabel); dashRow.appendChild(dashPreset); dashRow.appendChild(dashInput); props.appendChild(dashRow);

        const applyFromUI = () => {
          const sel = state.selection;
          if (!sel || sel.kind !== 'edge') return;
          const id = sel.id >>> 0;
          const hex = document.getElementById('strokeColor').value || '#1f6feb';
          const op = parseInt(document.getElementById('strokeOpacity').value || '100', 10);
          const w = parseFloat(document.getElementById('strokeWidth').value || '2');
          const [r_,g_,b_] = hexToRgb(hex);
          const a = Math.max(0, Math.min(255, Math.round((op/100) * 255)));
          try { if (typeof g.set_edge_style === 'function') { g.set_edge_style(id, r_|0, g_|0, b_|0, a|0, isFinite(w) ? w : 2); } } catch {}
          // Cap, join, dash (JS-side persistence)
          const cap = (document.getElementById('lineCap').value || 'round');
          const join = (document.getElementById('lineJoin').value || 'round');
          let dash = [];
          const preset = document.getElementById('lineDashPreset').value;
          const dashStr = document.getElementById('lineDash').value;
          if (preset === 'custom') {
            dash = parseDash(dashStr);
          } else if (preset) {
            dash = parseDash(preset);
          }
          state.edgeStyle[id] = { color: [r_|0, g_|0, b_|0, a|0], width: isFinite(w) ? w : 2, cap, join, dash };
          render();
        };
        colorInput.addEventListener('input', applyFromUI);
        opacityInput.addEventListener('input', () => { document.getElementById('strokeOpacityVal').textContent = (parseInt(opacityInput.value,10) || 0) + '%'; applyFromUI(); });
        widthInput.addEventListener('input', () => { document.getElementById('strokeWidthVal').textContent = (parseFloat(widthInput.value)||0).toFixed(1); applyFromUI(); });
        capSelect.addEventListener('change', applyFromUI);
        joinSelect.addEventListener('change', applyFromUI);
        dashPreset.addEventListener('change', () => {
          const v = dashPreset.value;
          if (v === 'custom') {
            dashInput.disabled = false;
          } else {
            dashInput.disabled = true;
          }
          applyFromUI();
        });
        dashInput.addEventListener('input', applyFromUI);
      }

      function hexToRgb(hex) {
        const v = String(hex||'').trim();
        const h = v[0] === '#' ? v.slice(1) : v;
        const n = h.length === 3 ? h.split('').map(c=>c+c).join('') : h;
        if (!/^[0-9a-fA-F]{6}$/.test(n)) return [31,111,235];
        const x = parseInt(n, 16);
        const r = (x>>16)&255, g = (x>>8)&255, b = x&255;
        return [r,g,b];
      }

      function rgbToHex(r,g,b) {
        const h = (n) => n.toString(16).padStart(2, '0');
        return '#' + h(r) + h(g) + h(b);
      }

      function parseDash(s) {
        if (!s) return [];
        return String(s).split(',').map(x => parseFloat(x.trim())).filter(n => isFinite(n) && n > 0);
      }

      function refreshPropertiesPanel() {
        ensurePropertiesPanel();
        const props = document.getElementById('props'); if (!props) return;
        const title = document.getElementById('propsTitle');
        const sel = state.selection;
        if (!sel || sel.kind !== 'edge') {
          if (title) title.textContent = 'No selection';
          // Disable inputs when no selection
          const inputs = props.querySelectorAll('input'); inputs.forEach(i => i.disabled = true);
          return;
        }
        // Enable inputs
        const inputs = props.querySelectorAll('input'); inputs.forEach(i => i.disabled = false);
        const id = sel.id >>> 0;
        if (title) title.textContent = `Path ${id}`;
        // Resolve style from engine first, fallback to JS map, else defaults
        let r=31,gc=111,b=235,a=255,w=2;
        try {
          const st = g.get_edge_style(id);
          let arr = null; try { arr = JSON.parse(JSON.stringify(st)); } catch { arr = st; }
          if (arr && arr.length >= 5) {
            r = (arr[0]|0)>>>0; gc = (arr[1]|0)>>>0; b = (arr[2]|0)>>>0; a = (arr[3]|0)>>>0; w = (typeof arr[4]==='number'&&isFinite(arr[4]))?arr[4]:2;
          }
        } catch {}
        if ((w === 2 && r===31 && gc===111 && b===235 && a===255) && state.edgeStyle && state.edgeStyle[id]) {
          const st = state.edgeStyle[id];
          if (st && st.color) { r = st.color[0]|0; gc = st.color[1]|0; b = st.color[2]|0; a = st.color[3]|0; }
          if (st && typeof st.width === 'number') w = st.width;
        }
        // Populate UI values
        const colorEl = document.getElementById('strokeColor');
        const opEl = document.getElementById('strokeOpacity');
        const opVal = document.getElementById('strokeOpacityVal');
        const wEl = document.getElementById('strokeWidth');
        const wVal = document.getElementById('strokeWidthVal');
        if (colorEl) colorEl.value = rgbToHex(r,gc,b);
        const pct = Math.round(Math.max(0, Math.min(1, (a||255)/255)) * 100);
        if (opEl) opEl.value = String(pct);
        if (opVal) opVal.textContent = pct + '%';
        if (wEl) wEl.value = String(isFinite(w)?w:2);
        if (wVal) wVal.textContent = (isFinite(w)?w:2).toFixed(1);
        // Cap/Join/Dash
        const capEl = document.getElementById('lineCap');
        const joinEl = document.getElementById('lineJoin');
        const dashPreset = document.getElementById('lineDashPreset');
        const dashEl = document.getElementById('lineDash');
        let cap = 'round', join = 'round', dash = [];
        const jsStyle = state.edgeStyle && state.edgeStyle[id];
        if (jsStyle) {
          cap = jsStyle.cap || cap;
          join = jsStyle.join || join;
          dash = Array.isArray(jsStyle.dash) ? jsStyle.dash.slice() : dash;
        }
        if (capEl) capEl.value = cap;
        if (joinEl) joinEl.value = join;
        if (dash && dash.length) { if (dashPreset) dashPreset.value = 'custom'; if (dashEl) { dashEl.disabled = false; dashEl.value = dash.join(','); } }
        else { if (dashPreset) dashPreset.value = ''; if (dashEl) { dashEl.disabled = true; dashEl.value = ''; } }
      }

      // Regions: recompute at most once per animation frame
      state.scheduledRegion = false;
      function scheduleRegions() {
        if (state.scheduledRegion) return;
        state.scheduledRegion = true;
        requestAnimationFrame(() => {
          state.scheduledRegion = false;
          const ver = g.geom_version();
          if (ver === state.regionsVersion) return;
          const regionsVal = g.get_regions();
          try { state.regions = JSON.parse(JSON.stringify(regionsVal)); }
          catch (e) { console.warn('regions normalize failed', e, regionsVal); state.regions = []; }
          state.regionsVersion = ver;
          render();
        });
      }

      function canvasPoint(evt) {
        const rect = canvas.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        return [x, y];
      }

      const GRID = 10;
      function snapPoint(x, y, excludeNodeId = null) {
        if (!state.snap) return [x, y];
        // Grid snap first
        let sx = Math.round(x / GRID) * GRID;
        let sy = Math.round(y / GRID) * GRID;
        // Snap to nearest node within radius
        const data = g.get_node_data();
        const ids = data.ids;
        const pos = data.positions;
        let bestId = null;
        let bestD2 = 12*12; // radius
        for (let i = 0; i < ids.length; i++) {
          const id = ids[i];
          if (excludeNodeId !== null && id === excludeNodeId) continue;
          const nx = pos[i*2+0];
          const ny = pos[i*2+1];
          const dx = nx - sx; const dy = ny - sy;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestD2) { bestD2 = d2; bestId = id; }
        }
        if (bestId !== null) {
          const n = g.get_node(bestId);
          if (n) { sx = n[0]; sy = n[1]; }
        }
        return [sx, sy];
      }

      canvas.addEventListener('mousedown', (evt) => {
        const [x, y] = canvasPoint(evt);
        // Pen tool interactions
        if (state.pen && state.penMode === 'points') {
          const [sx, sy] = snapPoint(x, y, null);
          const pickP = g.pick(sx, sy, 8);
          if (!state.penPath) {
            // Start path
            if (pickP && pickP.kind === 'node') {
              const id = pickP.id >>> 0;
              state.penPath = { startId: id, lastId: id };
            } else {
              const nid = g.add_node(sx, sy);
              state.penPath = { startId: nid, lastId: nid };
            }
            state.penPreview = [sx, sy];
            render();
            return;
          } else {
            // Extend path
            let targetId = null;
            if (pickP && pickP.kind === 'node') {
              targetId = pickP.id >>> 0;
            } else {
              targetId = g.add_node(sx, sy);
            }
            if (targetId != null && targetId !== state.penPath.lastId) {
              g.add_edge(state.penPath.lastId, targetId);
              state.penPath.lastId = targetId;
              scheduleRegions();
            }
            state.penPreview = [sx, sy];
            render();
            return;
          }
        }
        // Pen free draw: start stroke
        if (state.pen && state.penMode === 'free') {
          const [sx, sy] = snapPoint(x, y, null);
          state.freeDrawing = true;
          state.freePoints = [sx, sy];
          render();
          return;
        }

        const pick = g.pick(x, y, 10);
        if (state.bend && pick && pick.kind === 'edge') {
          state.bending = { edge: pick.id >>> 0, t: pick.t ?? 0.5 };
          return;
        }
        if (state.bucket && (!pick || !pick.kind)) {
          // Paint bucket: toggle the region under cursor
          const regions = state.regions;
          let hit = null;
          const list = Array.isArray(regions) ? regions : [];
          for (const r of list) {
            if (pointInPoly(x, y, r.points)) { hit = r; break; }
          }
          if (hit) {
            const after = g.toggle_region(hit.key >>> 0);
            for (const r of state.regions) { if (r.key === hit.key) { r.filled = after; break; } }
            console.log('Toggled region', hit.key, 'filled:', after);
            render();
          } else {
            console.log('No region under cursor at', x, y);
          }
          return;
        }
        if (pick && pick.kind === 'node') {
          const id = pick.id >>> 0;
          const n = g.get_node(id);
          state.selection = { kind: 'node', id };
          if (evt.altKey) {
            // Start connecting mode
            state.connecting = { startId: id, startPos: [n[0], n[1]], cur: [x, y] };
            state.dragging = null;
          } else {
            // Drag node
            state.dragging = { id, start: [x, y], orig: [n[0], n[1]] };
          }
        } else if (pick && pick.kind === 'handle') {
          const edge = pick.edge >>> 0;
          const end = pick.end >>> 0;
          state.selection = { kind: 'edge', id: edge };
          state.dragging = { handle: true, edge, end };
        } else if (pick && pick.kind === 'edge') {
          state.selection = { kind: 'edge', id: pick.id >>> 0 };
          state.dragging = null;
        } else {
          state.selection = null;
          state.dragging = null;
        }
        render();
      });

      window.addEventListener('mousemove', (evt) => {
        const [x, y] = canvasPoint(evt);
        if (state.pen && state.penMode === 'points' && state.penPath) {
          const [sx, sy] = snapPoint(x, y, null);
          state.penPreview = [sx, sy];
          render();
          return;
        }
        if (state.pen && state.penMode === 'free' && state.freeDrawing) {
          const [sx, sy] = snapPoint(x, y, null);
          const pts = state.freePoints || [];
          const n = pts.length;
          const lx = pts[n-2], ly = pts[n-1];
          const dx = sx - lx, dy = sy - ly;
          const d2 = dx*dx + dy*dy;
          if (d2 >= 9) { // sample every ~3px
            pts.push(sx, sy);
            state.freePoints = pts;
            render();
          }
          return;
        }
        if (state.bending) {
          const { edge, t } = state.bending;
          const [sx, sy] = snapPoint(x, y, null);
          g.bend_edge_to(edge, t, sx, sy, 1.0);
          scheduleRegions();
          render();
          return;
        }
        // Bucket hover detection
        if (state.bucket && !state.dragging && !state.connecting) {
          const regions = state.regions;
          let found = null;
          if (Array.isArray(regions)) {
            for (const r of regions) { if (pointInPoly(x, y, r.points)) { found = r; break; } }
          }
          state.hoverRegion = found;
          render();
        } else {
          state.hoverRegion = null;
        }
        // Hover update when idle
        if (!state.dragging && !state.connecting) {
          const h = g.pick(x, y, 10);
          if (h && h.kind === 'handle') {
            state.hover = { kind: 'handle', edge: h.edge >>> 0, end: h.end >>> 0 };
          } else if (h && h.kind) {
            state.hover = { kind: h.kind, id: h.id >>> 0 };
          } else {
            state.hover = null;
          }
        }
        // Connecting preview
        if (state.connecting) {
          const s = state.connecting;
          const snapped = snapPoint(x, y, s.startId);
          s.cur = snapped;
          render();
          return;
        }
        if (!state.dragging) return;
        if (state.dragging.handle) {
          const { edge, end } = state.dragging;
          const [sx, sy] = snapPoint(x, y, null);
          g.set_handle_pos(edge, end, sx, sy);
          scheduleRegions();
          render();
        } else {
          const snapped = snapPoint(x, y, state.dragging.id);
          const { id } = state.dragging;
          g.move_node(id, snapped[0], snapped[1]);
          scheduleRegions();
          render();
        }
      });

      window.addEventListener('mouseup', (evt) => {
        if (state.bending) { state.bending = null; return; }
        const [x, y] = canvasPoint(evt);
        // Finish free draw on mouseup
        if (state.pen && state.penMode === 'free' && state.freeDrawing) {
          const pts = Array.isArray(state.freePoints) ? state.freePoints.slice() : [];
          state.freeDrawing = false; state.freePoints = null;
          if (pts.length >= 4) {
            // Optionally close if end near start
            const dx = pts[pts.length-2] - pts[0];
            const dy = pts[pts.length-1] - pts[1];
            const close = (dx*dx + dy*dy) <= 12*12;
            // Decimate intermediate points
            const out = [pts[0], pts[1]];
            let px = pts[0], py = pts[1];
            for (let i = 2; i < pts.length-2; i += 2) {
              const cx = pts[i], cy = pts[i+1];
              const ddx = cx - px, ddy = cy - py;
              if ((ddx*ddx + ddy*ddy) >= 16) { out.push(cx, cy); px = cx; py = cy; }
            }
            const endX = pts[pts.length-2], endY = pts[pts.length-1];
            // Build polyline edge: endpoints become nodes; out (excluding endpoints) are internal points
            const startId = g.add_node(out[0], out[1]);
            const endId = g.add_node(endX, endY);
            // Internal points are out.slice(2)
            const internal = out.slice(2);
            try {
              if (typeof g.add_polyline_edge === 'function') {
                g.add_polyline_edge(startId, endId, new Float32Array(internal));
              } else {
                const eid = g.add_edge(startId, endId);
                if (eid != null && typeof g.set_edge_polyline === 'function') g.set_edge_polyline(eid, new Float32Array(internal));
              }
            } catch {}
            scheduleRegions();
            render();
          }
          return;
        }
        if (state.connecting) {
          const s = state.connecting; state.connecting = null;
          // If mouse up over a node, connect them
          const p = g.pick(x, y, 10);
          if (p && p.kind === 'node') {
            const endId = p.id >>> 0;
            if (endId !== s.startId) {
              g.add_edge(s.startId, endId);
              scheduleRegions();
            }
          }
          render();
          return;
        }
        if (!state.dragging) return;
        if (state.dragging.handle) {
          state.dragging = null;
        } else {
          const { id, orig } = state.dragging;
          state.dragging = null;
          const after = g.get_node(id);
          if (after && (after[0] !== orig[0] || after[1] !== orig[1])) {
            state.history.push({
              type: 'move_node', id,
              before: orig.slice(), after: [after[0], after[1]]
            });
            state.redo.length = 0; // clear redo on new action
          }
        }
      });

      window.addEventListener('keydown', (evt) => {
        const mod = evt.ctrlKey || evt.metaKey;
        if (mod && evt.key.toLowerCase() === 'z') {
          evt.preventDefault();
          if (evt.shiftKey) {
            // redo
            const op = state.redo.pop();
            if (op && op.type === 'move_node') {
              g.move_node(op.id, op.after[0], op.after[1]);
              state.history.push(op);
              render();
            }
          } else {
            // undo
            const op = state.history.pop();
            if (op && op.type === 'move_node') {
              g.move_node(op.id, op.before[0], op.before[1]);
              state.redo.push(op);
              render();
            }
          }
        } else if (evt.key.toLowerCase() === 's') {
          state.snap = !state.snap; updateSnapLabel(); render();
        } else if (evt.key.toLowerCase() === 'f') {
          state.bucket = !state.bucket; if (state.bucket) { state.pen = false; state.bend = false; } updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'b') {
          state.bend = !state.bend; if (state.bend) { state.pen = false; state.bucket = false; } updateModeLabel(); render();
        } else if (evt.key.toLowerCase() === 'p') {
          state.pen = !state.pen; if (state.pen) { state.bend = false; state.bucket = false; } else { state.penPath = null; state.penPreview = null; }
          updateModeLabel(); render();
        } else if (evt.key === 'Enter') {
          if (state.pen && state.penPath) { state.penPath = null; state.penPreview = null; render(); }
        } else if (evt.key === 'Escape') {
          if (state.pen && state.penPath) { state.penPath = null; state.penPreview = null; render(); }
        } else if (evt.key.toLowerCase() === 'r') {
          const refBtn = document.getElementById('refBtn');
          state.showRef = !state.showRef; if (refBtn) refBtn.classList.toggle('active', state.showRef); render();
        } else if (evt.key.toLowerCase() === 'c') {
          // Convert selected edge to cubic with default handles
          if (state.selection && state.selection.kind === 'edge') {
            const id = state.selection.id;
            const ed = g.get_edge_data();
            const idx = Array.from(ed.ids).indexOf(id);
            if (idx >= 0) {
              const aId = ed.endpoints[idx*2+0];
              const bId = ed.endpoints[idx*2+1];
              const a = g.get_node(aId); const b = g.get_node(bId);
              const dx = b[0] - a[0]; const dy = b[1] - a[1];
              const len = Math.hypot(dx, dy) || 1;
              const k = 0.3 * len;
              const p1x = a[0] + (dx/len) * k;
              const p1y = a[1] + (dy/len) * k;
              const p2x = b[0] - (dx/len) * k;
              const p2y = b[1] - (dy/len) * k;
              g.set_edge_cubic(id, p1x, p1y, p2x, p2y);
              render();
            }
          }
        } else if (evt.key.toLowerCase() === 'm') {
          // Cycle handle mode for selected cubic edge
          if (state.selection && state.selection.kind === 'edge') {
            const id = state.selection.id;
            const e = g.get_edge_data();
            const idx = Array.from(e.ids).indexOf(id);
            if (idx >= 0 && e.kinds[idx] === 1) {
              state.mode = (state.mode || 0) + 1; if (state.mode > 2) state.mode = 0;
              g.set_handle_mode(id, state.mode);
              render();
            }
          }
        }
      });

      // Double-click: finish pen path (optionally close if near start)
      canvas.addEventListener('dblclick', (evt) => {
        if (state.pen && state.penPath) {
          const [x, y] = canvasPoint(evt);
          const [sx, sy] = snapPoint(x, y, null);
          const start = g.get_node(state.penPath.startId);
          const last = g.get_node(state.penPath.lastId);
          if (start && last) {
            const dx = sx - start[0]; const dy = sy - start[1];
            const close = (dx*dx + dy*dy) <= 12*12;
            if (close && state.penPath.lastId !== state.penPath.startId) {
              g.add_edge(state.penPath.lastId, state.penPath.startId);
              scheduleRegions();
            }
          }
          state.penPath = null; state.penPreview = null; render();
          return;
        }
        // Legacy: add node on double click when not in pen mode
        const [x, y] = canvasPoint(evt);
        const [sx, sy] = snapPoint(x, y, null);
        g.add_node(sx, sy);
        render();
      });

      function pointInPoly(x, y, pts) {
        // pts is [x0,y0,x1,y1,...]
        if (!pts || typeof pts.length !== 'number' || pts.length < 6) return false;
        // Treat near-boundary as inside to avoid flicker
        if (pointNearPolyEdge(x, y, pts, 0.75)) return true;
        let inside = false;
        for (let i = 0, j = pts.length - 2; i < pts.length; j = i, i += 2) {
          const xi = pts[i], yi = pts[i+1];
          const xj = pts[j], yj = pts[j+1];
          const denom = (yj - yi) || 1e-9;
          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / denom + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function pointNearPolyEdge(x, y, pts, eps) {
        const eps2 = eps * eps;
        for (let i = 0; i < pts.length; i += 2) {
          const x1 = pts[i], y1 = pts[i+1];
          const x2 = pts[(i+2)%pts.length], y2 = pts[(i+3)%pts.length];
          const d2 = dist2PointToSeg(x, y, x1, y1, x2, y2);
          if (d2 <= eps2) return true;
        }
        return false;
      }

      function dist2PointToSeg(px, py, x1, y1, x2, y2) {
        const vx = x2 - x1, vy = y2 - y1;
        const wx = px - x1, wy = py - y1;
        const vv = vx*vx + vy*vy;
        let t = vv > 0 ? (wx*vx + wy*vy) / vv : 0;
        if (t < 0) t = 0; else if (t > 1) t = 1;
        const sx = x1 + t*vx, sy = y1 + t*vy;
        const dx = px - sx, dy = py - sy;
        return dx*dx + dy*dy;
      }

      // Buttons: Save/Load/Clear
      document.getElementById('saveBtn').addEventListener('click', () => {
        try {
          const obj = g.to_json();
          localStorage.setItem('contour_doc', JSON.stringify(obj));
        } catch (e) { console.warn('Save failed', e); }
      });
      document.getElementById('loadBtn').addEventListener('click', () => {
        try {
          const saved = localStorage.getItem('contour_doc') || localStorage.getItem('vecnet_doc');
          if (saved) { g.from_json(JSON.parse(saved)); scheduleRegions(); render(); }
        } catch (e) { console.warn('Load failed', e); }
      });
      document.getElementById('clearBtn').addEventListener('click', () => {
        g.clear();
        scheduleRegions(); render();
      });

      // Import SVG (file input + button)
      function importSvgText(text) {
        try {
          const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
          const paths = Array.from(doc.querySelectorAll('path'));
          let added = 0;
          const imported = [];
          const newSvgStrokes = [];
          const newSvgFills = [];
          // Hidden SVG probe for robust isPointInFill tests
          let probe = null;
          try {
            const root = doc.querySelector('svg');
            const viewBox = root ? (root.getAttribute('viewBox') || '0 0 2048 2048') : '0 0 2048 2048';
            probe = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            probe.setAttribute('viewBox', viewBox);
            probe.setAttribute('width', '0'); probe.setAttribute('height', '0');
            probe.style.position = 'absolute'; probe.style.left = '-99999px'; probe.style.top = '-99999px';
            document.body.appendChild(probe);
          } catch { probe = null; }
          for (const p of paths) {
            const d = p.getAttribute('d');
            if (!d || !d.trim()) continue;
            const { color } = resolveFillAndOpacity(p);
            const rule = resolveFillRule(p);
            const transform = p.getAttribute('transform') || null;
            const { strokeColor, strokeWidth } = resolveStroke(p);
            const before = new Set(Array.from((g.get_edge_data().ids) || []));
            try {
              if (strokeColor && strokeWidth != null && typeof g.add_svg_path_with_style === 'function') {
                const [sr,sg,sb,sa] = strokeColor;
                added += g.add_svg_path_with_style(d, sr|0, sg|0, sb|0, sa|0, Math.max(0.5, strokeWidth));
              } else {
                added += g.add_svg_path(d);
              }
              // Gather new edge ids and store style mapping (JS fallback always)
              const after = Array.from((g.get_edge_data().ids) || []);
              const newIds = after.filter(id => !before.has(id));
              if (strokeColor && strokeWidth != null) {
                const [rr,gg,bb,aa] = strokeColor;
                for (const eid of newIds) {
                  if (typeof g.set_edge_style === 'function') {
                    try { g.set_edge_style(eid, rr|0, gg|0, bb|0, aa|0, Math.max(0.5, strokeWidth)); } catch {}
                  }
                  state.edgeStyle[eid] = { color: [rr|0, gg|0, bb|0, aa|0], width: Math.max(0.5, strokeWidth) };
                }
                // Also record for reference overlay rendering
                newSvgStrokes.push({ d, color: [rr|0, gg|0, bb|0, aa|0], width: Math.max(0.5, strokeWidth), cap: (p.getAttribute('stroke-linecap')||'round'), join: (p.getAttribute('stroke-linejoin')||'round') });
              }
              // Create a probe path element for SVGGeometryElement.isPointInFill if available
              let el = null;
              try {
                if (probe) {
                  el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                  el.setAttribute('d', d);
                  if (transform) el.setAttribute('transform', transform);
                  el.setAttribute('fill', (color && Array.isArray(color)) ? `rgba(${color[0]},${color[1]},${color[2]},1)` : '#000');
                  el.setAttribute('fill-rule', rule || 'nonzero');
                  probe.appendChild(el);
                }
              } catch { el = null; }
              imported.push({ d, color, rule, transform, el });
              if (color) newSvgFills.push({ d, color, rule, transform });
            } catch (e) { console.warn('add_svg_path failed', e); }
          }
          // Map fills (if any) to regions
          const updateFills = () => {
            const regionsVal = g.get_regions();
            let regions = [];
            try { regions = JSON.parse(JSON.stringify(regionsVal)); } catch {}
            // Normalize context transform to identity for hit-testing
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            // Detect if isPointInPath(Path2D, ...) works in this browser; Safari may be flaky
            let pathHitWorks = false;
            try {
              const testP = new Path2D('M -1 -1 L 1 -1 L 1 1 L -1 1 z');
              pathHitWorks = !!ctx.isPointInPath(testP, 0, 0, 'nonzero') || !!ctx.isPointInPath(testP, 0, 0);
            } catch { pathHitWorks = false; }
            // Tiny raster fallback for hit-testing when API is unsupported
            const raster = (() => {
              const S = 9; const K = 4; // 9x9 pixels, 4x supersample for stability
              const c = document.createElement('canvas'); c.width = S; c.height = S;
              return { S, K, c, ctx: c.getContext('2d') };
            })();
            function rasterHit(path2d, px, py, rule) {
              const c2 = raster.ctx; if (!c2) return false;
              const S = raster.S, K = raster.K;
              // Clear and set transform so that (px,py) lands at the center pixel
              c2.setTransform(1,0,0,1,0,0); c2.clearRect(0,0,S,S);
              const cx = (S-1)/2, cy = (S-1)/2;
              c2.setTransform(K, 0, 0, K, -px*K + cx, -py*K + cy);
              c2.fillStyle = '#000';
              try {
                if (typeof c2.addPath === 'function') {
                  c2.beginPath(); c2.addPath(path2d);
                  if (typeof c2.fill === 'function' && c2.fill.length >= 1) c2.fill(rule || 'nonzero'); else c2.fill();
                } else if (typeof c2.fill === 'function') {
                  if (c2.fill.length >= 2) c2.fill(path2d, rule || 'nonzero'); else c2.fill(path2d);
                } else { return false; }
              } catch { return false; }
              const img = c2.getImageData(0,0,S,S).data;
              for (let i=3; i<img.length; i+=4) { if (img[i] > 0) return true; }
              return false;
            }
            let coloredAny = false;
            const importedWithColor = imported.filter(imp => imp && imp.color);
            console.log('Import fill items:', importedWithColor.length);
            for (const imp of importedWithColor) {
              const path2d = new Path2D(imp.d);
              const rule = (imp.rule === 'evenodd') ? 'evenodd' : 'nonzero';
              // Optional: support element transform by mapping the test point into path space
              let inv = null;
              try {
                if (imp.transform && typeof DOMMatrix === 'function') {
                  inv = new DOMMatrix(String(imp.transform)).inverse();
                }
              } catch {}
              for (const r of regions) {
                if (!r || !Array.isArray(r.points) || r.points.length < 2) continue;
                const c = centroidOfPoints(r.points);
                let px = c[0], py = c[1];
                if (inv && typeof DOMPoint === 'function') {
                  const p2 = new DOMPoint(c[0], c[1]).matrixTransform(inv);
                  px = p2.x; py = p2.y;
                }
                let inside = false;
                // 1) Prefer native SVG hit test if available
                if (!inside && imp.el && typeof imp.el.isPointInFill === 'function') {
                  try {
                    const pt = (probe && typeof probe.createSVGPoint === 'function') ? probe.createSVGPoint() : null;
                    if (pt) { pt.x = px; pt.y = py; inside = !!imp.el.isPointInFill(pt); }
                  } catch { inside = false; }
                }
                // 2) Canvas Path2D hit-test
                if (!inside) {
                  try {
                    if (pathHitWorks) {
                      if (typeof ctx.isPointInPath === 'function' && ctx.isPointInPath.length >= 4) inside = !!ctx.isPointInPath(path2d, px, py, rule);
                      else inside = !!ctx.isPointInPath(path2d, px, py);
                    }
                  } catch { /* ignore */ }
                }
                // 3) Raster fallback
                if (!inside) inside = rasterHit(path2d, px, py, rule);
                if (inside) {
                  const [rr,gg,bb,aa] = imp.color;
                  g.set_region_fill(r.key >>> 0, true);
                  g.set_region_color(r.key >>> 0, rr, gg, bb, aa);
                  coloredAny = true;
                }
              }
            }
            ctx.restore();
            // Clean up probe DOM
            try { if (probe && probe.parentNode) probe.parentNode.removeChild(probe); } catch {}
            console.log('Applied fill colors?', coloredAny);
            // If no fills assigned at all, turn fills off
            let afterColor = g.get_regions();
            let arr = [];
            try { arr = JSON.parse(JSON.stringify(afterColor)); } catch { arr = []; }
            // Only disable fills when there were no imported fill colors at all; otherwise keep default fallback fill
            if (importedWithColor.length === 0 && !arr.some(r => r && r.color && r.color.length === 4)) {
              for (const r of arr) { g.set_region_fill(r.key >>> 0, false); }
              afterColor = g.get_regions();
            }
            try { state.regions = JSON.parse(JSON.stringify(afterColor)); } catch { state.regions = []; }
            try {
              const stats = { total: state.regions.length, colored: 0, filled: 0 };
              for (const r of state.regions) {
                if (!r) continue;
                if (r.filled) stats.filled++;
                if (r.color && r.color.length === 4) stats.colored++;
              }
              console.log('Region stats:', stats);
            } catch {}
            state.regionsVersion = g.geom_version();
            // Enable reference overlay and store strokes + fills
            state.svgStrokes = newSvgStrokes;
            state.svgFills = newSvgFills;
            state.showRef = state.svgStrokes.length > 0;
            fitToView();
            render();
          };
          if (added > 0) requestAnimationFrame(updateFills); else updateFills();
          console.log(`Imported ${paths.length} <path> tags; edges added: ${added}`);
          console.log('Parsed strokes:', newSvgStrokes.length, newSvgStrokes.slice(0,3));
        } catch (e) { console.warn('SVG parse/import failed', e); }
      }

      // Build objects panel: one entry per edge with a small preview
      function rebuildObjectList() {
        const list = document.getElementById('objList'); if (!list) return;
        list.innerHTML = '';
        const e = g.get_edge_data();
        const ids = e.ids || [];
        const ep = e.endpoints || [];
        const kinds = e.kinds || [];
        const rgba = e.stroke_rgba || [];
        const widths = e.stroke_widths || [];
        for (let i = 0; i < ids.length; i++) {
          const edgeId = ids[i];
          const aId = ep[i*2+0];
          const bId = ep[i*2+1];
          const a = g.get_node(aId); const b = g.get_node(bId);
          if (!a || !b) continue;
          const row = document.createElement('div');
          row.style.cssText = 'display:flex; gap:8px; align-items:center; padding:6px; border:1px solid #eee; border-radius:6px; background:#fff; cursor:pointer;';
          const canvas = document.createElement('canvas');
          canvas.width = 120; canvas.height = 60;
          canvas.style.cssText = 'width:120px; height:60px; background:#fff; border:1px solid #eee; border-radius:4px;';
          const label = document.createElement('div');
          label.textContent = `Path ${edgeId}`;
          label.style.cssText = 'font-size:12px; color:#333;';
          row.appendChild(canvas); row.appendChild(label);
          row.addEventListener('click', () => { state.selection = { kind:'edge', id: edgeId }; render(); });
          list.appendChild(row);

          // Draw preview
          try {
            const ctx2 = canvas.getContext('2d');
            ctx2.clearRect(0,0,canvas.width,canvas.height);
            // Determine color/width
            let col = 'rgba(31,111,235,1)';
            let w = 2;
            let cap = 'round';
            let join = 'round';
            let dash = [];
            if (rgba && rgba.length >= (i*4+4) && widths && widths.length > i) {
              const r = rgba[i*4+0]||0, g2=rgba[i*4+1]||0, b2=rgba[i*4+2]||0, a2=rgba[i*4+3]||255;
              if (a2>0) col = `rgba(${r},${g2},${b2},${Math.max(0,Math.min(1,a2/255))})`;
              if (widths[i]>0) w = widths[i];
            } else if (state.edgeStyle && state.edgeStyle[edgeId]) {
              const st = state.edgeStyle[edgeId]; const [r,g3,b3,a3] = st.color||[31,111,235,255];
              col = `rgba(${r},${g3},${b3},${Math.max(0,Math.min(1,(a3||255)/255))})`; w = st.width||2; cap = st.cap||cap; join = st.join||join; dash = Array.isArray(st.dash)?st.dash:dash;
            }
            // Compute bounds using endpoints + handles (convex hull bounds)
            let pts = [a[0],a[1]];
            if (kinds[i] === 1) {
              const h = g.get_handles(edgeId); if (h) { pts.push(h[0],h[1], h[2],h[3]); }
            } else if (kinds[i] === 2) {
              try { const a = g.get_polyline_points(edgeId); const arr = Array.from(a||[]); for (let t=0;t<arr.length;t+=2){ pts.push(arr[t], arr[t+1]); } } catch {}
            }
            pts.push(b[0],b[1]);
            let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
            for (let k=0;k<pts.length;k+=2){ const x=pts[k], y=pts[k+1]; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) continue;
            const pad = 6; const boxW = Math.max(1,maxX-minX), boxH=Math.max(1,maxY-minY);
            const sx = (canvas.width-2*pad)/boxW, sy=(canvas.height-2*pad)/boxH; const s=Math.min(sx,sy);
            const ox = pad - minX*s; const oy = pad - minY*s;
            ctx2.save(); ctx2.translate(ox,oy); ctx2.scale(s,s);
            ctx2.beginPath(); ctx2.moveTo(a[0],a[1]);
            if (kinds[i] === 1) {
              const h = g.get_handles(edgeId); if (h) ctx2.bezierCurveTo(h[0],h[1],h[2],h[3], b[0],b[1]);
              else ctx2.lineTo(b[0],b[1]);
            } else if (kinds[i] === 2) {
              try { const a = g.get_polyline_points(edgeId); const arr = Array.from(a||[]); for (let t=0;t<arr.length;t+=2){ ctx2.lineTo(arr[t], arr[t+1]); } ctx2.lineTo(b[0],b[1]); } catch { ctx2.lineTo(b[0],b[1]); }
            } else {
              ctx2.lineTo(b[0],b[1]);
            }
            ctx2.strokeStyle = col; ctx2.lineWidth = Math.max(1, w * s);
            ctx2.lineCap=cap; ctx2.lineJoin=join; ctx2.setLineDash(Array.isArray(dash)?dash.map(x=>x*s):[]); ctx2.stroke(); ctx2.setLineDash([]); ctx2.restore();
          } catch (e) { /* ignore */ }
        }
      }
      // Resolve fill color and opacity with basic inheritance (path -> ancestors),
      // defaulting to black if nothing specified (SVG default fill).
      function resolveFillAndOpacity(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { fill: m('fill'), fillOpacity: m('fill-opacity'), opacity: m('opacity') };
        };
        let cur = el;
        let fill = null;
        let fo = null;
        let op = null;
        while (cur) {
          const fAttr = cur.getAttribute && cur.getAttribute('fill');
          const foAttr = cur.getAttribute && cur.getAttribute('fill-opacity');
          const opAttr = cur.getAttribute && cur.getAttribute('opacity');
          const st = readStyle(cur);
          if (fill == null && fAttr != null) fill = fAttr;
          if (fill == null && st.fill != null) fill = st.fill;
          if (fo == null && foAttr != null) fo = foAttr;
          if (fo == null && st.fillOpacity != null) fo = st.fillOpacity;
          if (op == null && opAttr != null) op = opAttr;
          if (op == null && st.opacity != null) op = st.opacity;
          cur = cur.parentNode;
        }
        // Default SVG fill is black if not 'none'
        const opacity = clamp01(parseFloat(fo ?? op ?? '1'));
        // SVG default is black when fill unspecified; honor 'none'.
        const color = parseCssColor(fill == null || String(fill).trim() === '' ? 'black' : fill, opacity);
        return { color };
      }
      function resolveFillRule(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { rule: m('fill-rule') };
        };
        let cur = el; let rule = null;
        while (cur) {
          const attr = cur.getAttribute && cur.getAttribute('fill-rule');
          const st = readStyle(cur);
          if (rule == null && attr != null) rule = String(attr).toLowerCase();
          if (rule == null && st.rule != null) rule = String(st.rule).toLowerCase();
          cur = cur.parentNode;
        }
        return (rule === 'evenodd' || rule === 'nonzero') ? rule : 'nonzero';
      }
      function clamp01(v) { if (!isFinite(v)) return 1; if (v < 0) return 0; if (v > 1) return 1; return v; }
      function parseCssColor(value, opacity=1) {
        if (!value || value === 'none') return null;
        const v = String(value).trim();
        // Tolerant rgb/rgba parser that clamps out-of-range channels
        const m = v.match(/^rgba?\(([^)]+)\)$/i);
        if (m) {
          const parts = m[1].split(',').map(s=>s.trim());
          const to255 = (x) => {
            const n = parseFloat(x);
            if (!isFinite(n)) return 0;
            return Math.max(0, Math.min(255, Math.round(n)));
          };
          const r = to255(parts[0]);
          const g = to255(parts[1]);
          const b = to255(parts[2]);
          const aPart = parts[3] != null ? clamp01(parseFloat(parts[3])) : 1;
          const a = Math.round(clamp01(aPart * opacity) * 255);
          return [r,g,b,a];
        }
        // Hex codes
        if (v[0] === '#') {
          const hex = v.slice(1);
          const norm = hex.length === 3 ? hex.split('').map(c=>c+c).join('') : hex;
          if (/^[0-9a-fA-F]{6}$/.test(norm)) {
            const n = parseInt(norm, 16);
            const r = (n >> 16) & 255, g = (n >> 8) & 255, b = n & 255;
            const a = Math.round(clamp01(opacity) * 255);
            return [r,g,b,a];
          }
        }
        // Named colors: use canvas fallback
        try {
          const c = document.createElement('canvas');
          const cx = c.getContext('2d');
          cx.fillStyle = v;
          const norm = cx.fillStyle;
          const m2 = norm.match(/rgba?\(([^)]+)\)/i);
          if (!m2) return null;
          const parts = m2[1].split(',').map(s=>s.trim());
          const r = parseInt(parts[0],10), g = parseInt(parts[1],10), b = parseInt(parts[2],10);
          const aPart = parts[3] != null ? clamp01(parseFloat(parts[3])) : 1;
          const a = Math.round(clamp01(aPart * opacity) * 255);
          return [r,g,b,a];
        } catch { return null; }
      }
      function centroidOfPoints(pts) {
        // pts: [x0,y0,x1,y1,...]
        if (!pts || typeof pts.length !== 'number' || pts.length < 2) return [0, 0];
        if (pts.length < 6) return [pts[0], pts[1]];
        let area = 0, cx = 0, cy = 0;
        for (let i = 0, j = pts.length-2; i < pts.length; j = i, i += 2) {
          const x0 = pts[j], y0 = pts[j+1], x1 = pts[i], y1 = pts[i+1];
          const cross = x0*y1 - x1*y0; area += cross; cx += (x0 + x1) * cross; cy += (y0 + y1) * cross;
        }
        area *= 0.5; if (Math.abs(area) < 1e-6) return [pts[0], pts[1]];
        return [cx/(6*area), cy/(6*area)];
      }

      function fitToView(padding = 20) {
        // Compute bbox of full geometry: nodes + cubic handles + polyline points.
        // This avoids under-estimating curves that bulge beyond endpoints.
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        // Nodes
        try {
          const data = g.get_node_data();
          const pos = data && data.positions;
          if (pos && pos.length >= 2) {
            for (let i = 0; i < pos.length; i += 2) {
              const x = pos[i], y = pos[i+1];
              if (!isFinite(x) || !isFinite(y)) continue;
              if (x < minX) minX = x; if (y < minY) minY = y;
              if (x > maxX) maxX = x; if (y > maxY) maxY = y;
            }
          }
        } catch {}

        // Edges: include control points and polyline internal points
        try {
          const e = g.get_edge_data();
          const ids = e && e.ids || [];
          const ep = e && e.endpoints || [];
          const kinds = e && e.kinds || [];
          for (let i = 0; i < ids.length; i++) {
            const aId = ep[i*2+0];
            const bId = ep[i*2+1];
            const a = g.get_node(aId);
            const b = g.get_node(bId);
            if (a && b) {
              const pts = [a[0], a[1], b[0], b[1]];
              if (kinds[i] === 1) { // cubic: add handles
                const h = g.get_handles(ids[i]);
                if (h) pts.push(h[0], h[1], h[2], h[3]);
              } else if (kinds[i] === 2) { // polyline: add interior points
                try { const arr = Array.from(g.get_polyline_points(ids[i]) || []); for (let k=0;k+1<arr.length;k+=2) pts.push(arr[k], arr[k+1]); } catch {}
              }
              for (let k = 0; k+1 < pts.length; k += 2) {
                const x = pts[k], y = pts[k+1];
                if (!isFinite(x) || !isFinite(y)) continue;
                if (x < minX) minX = x; if (y < minY) minY = y;
                if (x > maxX) maxX = x; if (y > maxY) maxY = y;
              }
            }
          }
        } catch {}

        if (!(isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY))) return;

        const width = canvas.width / (window.devicePixelRatio || 1);
        const height = canvas.height / (window.devicePixelRatio || 1);
        const boxW = Math.max(1, maxX - minX);
        const boxH = Math.max(1, maxY - minY);
        const sx = (width - 2*padding) / boxW;
        const sy = (height - 2*padding) / boxH;
        const s = Math.max(0.0001, Math.min(sx, sy));
        const tx = padding - minX * s;
        const ty = padding - minY * s;

        // Uniformly transform graph to preserve curve shapes and handle offsets
        g.transform_all(s, tx, ty, true);
        state.transform = { s, tx, ty };
        scheduleRegions();
      }

      function resolveStroke(el) {
        const readStyle = (node) => {
          const style = (node.getAttribute && node.getAttribute('style')) || '';
          const m = (name) => { const r = style.match(new RegExp(`${name}\\s*:\\s*([^;]+)`,'i')); return r ? r[1].trim() : null; };
          return { stroke: m('stroke'), strokeOpacity: m('stroke-opacity'), strokeWidth: m('stroke-width'), opacity: m('opacity') };
        };
        let cur = el;
        let stroke = null;
        let so = null;
        let sw = null;
        let op = null;
        while (cur) {
          const sAttr = cur.getAttribute && cur.getAttribute('stroke');
          const soAttr = cur.getAttribute && cur.getAttribute('stroke-opacity');
          const swAttr = cur.getAttribute && cur.getAttribute('stroke-width');
          const opAttr = cur.getAttribute && cur.getAttribute('opacity');
          const st = readStyle(cur);
          if (stroke == null && sAttr != null) stroke = sAttr;
          if (stroke == null && st.stroke != null) stroke = st.stroke;
          if (so == null && soAttr != null) so = soAttr;
          if (so == null && st.strokeOpacity != null) so = st.strokeOpacity;
          if (sw == null && swAttr != null) sw = swAttr;
          if (sw == null && st.strokeWidth != null) sw = st.strokeWidth;
          if (op == null && opAttr != null) op = opAttr;
          if (op == null && st.opacity != null) op = st.opacity;
          cur = cur.parentNode;
        }
        if (!stroke || stroke === 'none') return { strokeColor: null, strokeWidth: null };
        const opacity = clamp01(parseFloat(so ?? op ?? '1'));
        const strokeColor = parseCssColor(stroke, opacity);
        const strokeWidth = parseFloat(sw ?? '2');
        return { strokeColor, strokeWidth: isFinite(strokeWidth) ? strokeWidth : 2 };
      }
      const importInput = document.getElementById('importSvgInput');
      document.getElementById('importBtn').addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', (evt) => {
        const file = evt.target.files && evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => { importSvgText(String(reader.result || '')); importInput.value = ''; };
        reader.onerror = (e) => { console.warn('File read failed', e); importInput.value = ''; };
        reader.readAsText(file);
      });

      // Drag-and-drop SVG onto the canvas
      canvas.addEventListener('dragover', (evt) => { evt.preventDefault(); evt.dataTransfer.dropEffect = 'copy'; });
      canvas.addEventListener('drop', (evt) => {
        evt.preventDefault();
        const dt = evt.dataTransfer;
        if (!dt || !dt.files || dt.files.length === 0) return;
        const file = dt.files[0];
        if (!file.type.includes('svg') && !file.name.toLowerCase().endsWith('.svg')) { console.warn('Not an SVG'); return; }
        const reader = new FileReader();
        reader.onload = () => importSvgText(String(reader.result || ''));
        reader.onerror = (e) => console.warn('Drop read failed', e);
        reader.readAsText(file);
      });

      const penBtn = document.getElementById('penBtn');
      if (penBtn) penBtn.addEventListener('click', () => { state.pen = !state.pen; if (state.pen) { state.bend = false; state.bucket = false; } else { state.penPath = null; state.penPreview = null; } updateModeLabel(); render(); });
      const penModeSel = document.getElementById('penMode');
      if (penModeSel) penModeSel.addEventListener('change', (e) => {
        const v = e.target && e.target.value ? String(e.target.value) : 'points';
        state.penMode = (v === 'free') ? 'free' : 'points';
        // Cancel any in-progress drawing for clean switch
        state.penPath = null; state.penPreview = null; state.freeDrawing = false; state.freePoints = null;
        updateModeLabel(); render();
      });
      document.getElementById('bucketBtn').addEventListener('click', () => {
        state.bucket = !state.bucket; if (state.bucket) { state.pen = false; state.bend = false; } updateModeLabel(); render();
      });
      document.getElementById('bendBtn').addEventListener('click', () => {
        state.bend = !state.bend; if (state.bend) { state.pen = false; state.bucket = false; } updateModeLabel(); render();
      });
      const refBtn = document.getElementById('refBtn');
      if (refBtn) {
        refBtn.addEventListener('click', () => {
          state.showRef = !state.showRef;
          refBtn.classList.toggle('active', state.showRef);
          render();
        });
      }

      render();
    </script>
  </body>
  </html>
